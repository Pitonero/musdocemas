<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
	<script src="https://cdn.socket.io/4.6.1/socket.io.min.js"></script>
    <title>Musdocemas - Mesa de Juego</title>
    <style>
	
	.cabecera {
		display: flex; /* Usamos flexbox para alinear los elementos */
		align-items: center; /* Centra verticalmente los elementos */
		justify-content: space-between; /* Empuja los elementos a los extremos */
		padding: 0; /* Mantén el padding actual o ajústalo según tu diseño */
		padding: 10px; /* Espaciado interno */
		position: relative; /* Permite centrar el texto del <h1> */
	}

	.cabecera h1 {
		margin: 0; /* Elimina márgenes */
		font-size: 1.5rem; /* Tamaño del texto del título */
		text-align: center; /* Centra el texto dentro del <h1> */
		flex-grow: 1; /* Permite que el <h1> ocupe todo el espacio horizontal disponible */
	}
	
	.cabecera nav {
		margin-left: auto; /* Mueve el nav al extremo derecho */
	}
	
	.cabecera nav a {
		text-decoration: none; /* Mantén el estilo de enlaces estándar */
		font-size: 0.9rem; /* Texto más pequeño */		
		color: #fff; /* Texto blanco */
		/*background-color: #dc3545;  Fondo rojo para el botón */		
		font-size: 1rem; /* Ajusta el tamaño del texto según necesites */
		padding: 5px 8px; /* Espaciado interno */
		border: 1px solid transparent; /* Sin borde por defecto */
		border-radius: 4px; /* Bordes ligeramente redondeados */
		cursor: pointer; /* Muestra un cursor de mano */
	}

	.cabecera nav a:hover {
		background-color: #c82333; /* Color más oscuro en hover */
	}


	
        /* Estilos Generales */
        body {
            font-family: Arial, sans-serif;
            background-color: #2e2b3f;
            color: #fff;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            padding: 0;
        }
        header {
            width: 100%;
            background-color: #3a3354;
            padding: 10px 0;
            text-align: center;
        }
        header h1 {
            margin: 0;
        }

        /* Contenedor Principal */
        .contenedor {
            width: 90%;
            max-width: 1400px;
            display: flex;
            justify-content: space-between;
            margin-top: 20px;
        }

        /* Mesa de Juego  width: 70%;*/
        .mesa-de-juego {
			/*overflow: hidden; Opcional, por si hay contenido que desborde */           
            background-color: #4e495e;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0px 0px 10px rgba(0, 0, 0, 0.5);
			box-sizing: border-box;
            display: grid;
            grid-template-rows: 1fr auto 1fr;
            grid-template-columns: 1fr auto 1fr;
            gap: 20px;
            align-items: center;
            justify-items: center;
            position: relative;

  width: 100%;
  height: auto;
/*  position: relative; Si es necesario para aislamiento */

        }

        /* Tablero de Puntuación */
		
.tablero {
  position: absolute;
  top: 20px;
  left: 20px;
  background-color: #2a2a2a;
  color: #ffffff;
  padding: 10px;
  margin: 10px; /* Ajusta el margen alrededor del tablero */
  border-radius: 8px;
  text-align: center;
  width: auto;
  min-width: 250px;
  display: block; /* Cambiar de inline-block a block */
  box-shadow: 0 0 10px rgba(0, 0, 0, 0.7); 
}

.tablero h2 {
  margin: 0 0 10px 0;
  font-size: 1.4em;
}

.puntuacion-tabla {
    border-collapse: collapse;
    width: 100%;
    background-color: #2b2b2b; /* Fondo general del tablero */
}

.puntuacion-tabla th, .puntuacion-tabla td {
    border: 2px solid #ffffff; /* Bordes blancos para destacar */
    padding: 10px;
    font-size: 1.4rem; /* Tamaño del texto aumentado */
    font-weight: bold; /* Letras más gruesas */
    text-align: center;
    color: #ffffff; /* Texto blanco */
    text-shadow: 2px 2px 3px rgba(0, 0, 0, 0.8); /* Sombra negra para mayor contraste */
}

.puntuacion-tabla th {
    background-color: #4b4b4b; /* Fondo gris oscuro para los encabezados */
}

.equipo-azul {
    background-color: rgba(0, 0, 255, 0.8); /* Fondo azul más claro */
    color: #ffffff; /* Texto blanco */
}

.equipo-rojo {
    background-color: rgba(255, 0, 0, 0.8); /* Fondo rojo más claro */
    color: #ffffff; /* Texto blanco */
}


/* Alias */
.alias {
    font-weight: bold;
    padding: 5px 10px;
    border-radius: 5px;
    font-size: 1.2rem; /* Tamaño del texto */
    text-align: center;
    color: #ffffff; /* Texto blanco para contrastar con los fondos */
    text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8); /* Sombra negra para mayor contraste */
}

.alias.equipo-azul {
    background-color: #0000ff; /* Fondo azul sólido */
    border: 2px solid #000080; /* Borde azul oscuro */
}

.alias.equipo-rojo {
    background-color: #ff0000; /* Fondo rojo sólido */
    border: 2px solid #800000; /* Borde rojo oscuro */
}


        /* Jugadores */
        .jugador {
            display: flex;
            align-items: center;
            flex-direction: column;
			position: relative;
			text-align: center;
			transition: transform 0.3s ease, font-size 0.3s ease;

        }
		
        .jugador img {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            margin-bottom: 5px;
            border: 2px solid #fff;
            box-shadow: 0px 4px 8px rgba(0, 0, 0, 0.3);
			transition: transform 0.3s ease; 
		}

		.jugador .alias {
			margin-top: 5px;
			font-size: 15px;
			font-weight: bold;
			position: relative; /* Necesario para posicionar el indicador relativo al alias */
			transition: font-size 0.3s ease, color 0.3s ease;
			}

		.jugador.mano img {
			transform: scale(1.2); /* Aumenta el tamaño del avatar */
			border-color: gold; /* Cambia el borde a un color llamativo */
			animation: blink 1s ease-in-out 3; /* Parpadeo */
		}

		/* Definición de la animación de parpadeo */
		@keyframes blink {
			0%, 100% {
				border-color: gold;
			}
			50% {
				border-color: transparent;
			}
		}
		.jugador.mano .alias {
			color: gold; /* Cambia el color del alias */
			font-size: 18px; /* Aumenta el tamaño del alias */
		}			
				/* Posición de los jugadores */
				.jugador-1 { grid-row: 3; grid-column: 2; }
				.jugador-3 { grid-row: 1; grid-column: 2; }
				.jugador-4 { grid-row: 2; grid-column: 1; }
				.jugador-2 { grid-row: 2; grid-column: 3; }

				/* Cartas */

.cartas {
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 2px; /* Espaciado entre cartas */
  padding: 0; /* Elimina relleno adicional */
  margin: 0; /* Elimina márgenes innecesarios */
  height: auto; /* Ajusta la altura al contenido */
  /*border: 2px dashed #3a3354;*/
  border-radius: 0;
  background-color: #E0E0E0; /*#f4f4f4;*/
}
.carta {
    width: 65px; /* Mantén el tamaño original */
    height: 100px; /* Mantén el tamaño original */
  background-size: 100% 100%;
  background-image: url('../static/img/cartas/zz.png'); /* Imagen de carta tapada */
  background-position: center center;
  background-repeat: no-repeat; /* Evita repeticiones de la imagen */
  will-change: transform;
  display: inline-block; /* Asegura que cada carta es independiente */
  position: relative;    /* Aísla la carta */
  transform-origin: center; /* Escala desde el centro */
  box-sizing: border-box; /* Asegúrate de incluir bordes en las dimensiones */  
  cursor: pointer;
  /*transition: transform 0.2s ease, border 0.2s ease;*/ /* Transición suave */
  border: 0; /* Elimina cualquier borde visible */
  border-radius: 0; /* Esquinas rectas */
} 

.carta.seleccionada {
  transform: scale(1.4) rotate(-5deg);
  box-shadow: 0 0 15px rgba(255, 255, 0, 0.8);
}
 /*background-color: #6c5b7b;
  color: #fff;
    overflow: hidden;
    display: flex;
    justify-content: center;
      font-size: 16px;
      font-weight: bold;
    align-items: center;
    position: relative;
    border-radius: 5px; /* Bordes redondeados */
    box-shadow: 0px 4px 8px rgba(0, 0, 0, 0.3);
  cursor: pointer;
  transition: transform 0.3s ease, box-shadow 0.3s ease;
}*/

.carta:active {
  cursor: grabbing;
}

.carta:hover {
  transform: none; /* No cambia el transform */
 /* transform: scale(1.05); */ /* Efecto de zoom al pasar el ratón */
  border: 2px solid #3a3354; /* Color del borde al pasar el ratón */
}

.carta.tapada {
  background-image: url('../static/img/cartas/zz.png'); /* Imagen de dorso */
  background-size: cover;
  background-position: center;
}

.carta img {
    width: 100%; /* La imagen se ajusta al ancho de la carta */
    height: auto; /* Mantiene la proporción de la imagen */
    display: block; /* Elimina espacios blancos adicionales */	
    object-fit: cover; /* Ajusta la imagen sin deformarla */
    border-radius: 1px; /* Un poco menos que el contenedor para mantener estilo */
}

		.carta-oculta {
			background-image: url('../static/img/cartas/zz.png');
			background-size: cover;
			background-position: center;
		}

        /* Panel de Botones para Jugador Principal */
        .botones {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            position: absolute;
            bottom: 55px;
            right: 15%;
        }
        .boton {
            padding: 8px 15px;
            background-color: #8b6fae;
            color: #fff;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9em;
            text-align: center;
            box-shadow: 0px 4px 8px rgba(0, 0, 0, 0.3);
            transition: background-color 0.3s ease;
        }
        .boton:hover {
            background-color: #a785d1;
        }

        /* Chat */
        .chat {
            width: 25%;
            background-color: #333;
            padding: 10px;
            border-radius: 8px;
            max-height: 500px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            box-shadow: 0px 4px 8px rgba(0, 0, 0, 0.5);
        }
        .chat h3 {
            color: #a785d1;
            margin-bottom: 10px;
        }
        .chat-mensaje {
			margin-bottom: 5px;
			font-size: 14px;
        }
        .chat-input {
            display: flex;
            margin-top: auto;
        }
        .chat-input input {
            flex: 1;
            padding: 10px;
            border: none;
            border-radius: 5px;
        }
        .chat-input button {
            padding: 10px 20px;
            margin-left: 5px;
            border: none;
            background-color: #645a7a;
            color: #fff;
            border-radius: 5px;
            cursor: pointer;
            box-shadow: 0px 4px 8px rgba(0, 0, 0, 0.3);
            transition: background-color 0.3s ease;
        }
        .chat-input button:hover {
            background-color: #7d6b92;
        }
		#chat-box {
			max-height: 400px; /* Ajusta según tus necesidades */
			overflow-y: auto;  /* Habilita el scroll vertical */
			border: 1px solid #ccc; /* Opcional, para visualización */
			padding: 10px;     /* Opcional, para estética */
		}
		
		
		.boton-repartir-container {
			position: absolute;
			top: 50%;
			left: 50%;
			transform: translate(-50%, -50%);
			z-index: 2; /* Para asegurarte de que está por encima del fondo */
		}

		#btn-repartir {
			padding: 15px 30px;
			font-size: 18px;
			font-weight: bold;
			color: #fff;
			background: linear-gradient(45deg, #4CAF50, #81C784); /* Gradiente atractivo */
			border: none;
			border-radius: 8px;
			cursor: pointer;
			box-shadow: 0px 4px 8px rgba(0, 0, 0, 0.3);
			transition: transform 0.2s, background-color 0.3s;
		}

		#btn-repartir:hover {
			transform: scale(1.1);
			background: linear-gradient(45deg, #388E3C, #66BB6A); /* Cambia a un gradiente más oscuro */
		}

		#btn-repartir:active {
			transform: scale(0.95);
			box-shadow: 0px 2px 4px rgba(0, 0, 0, 0.2);
		}
		.oculto {
			display: none;
		}
header {
    background-color: #4c4c4c; /* Fondo del header */
    padding: 15px; /* Espaciado interno */
    text-align: center; /* Centrar el texto */
    color: white; /* Color del texto */
}

header h1 {
    font-size: 24px; /* Tamaño del título general */
    margin: 0; /* Elimina márgenes */
}

header h1 .mesa-nombre {
    font-weight: bold; /* Negrita para el nombre de la mesa */
    font-size: 26px; /* Tamaño ligeramente mayor */
    color: #f0c674; /* Color diferenciado para el nombre de la mesa */
}

header h1 .usuario {
    font-weight: normal; /* Peso normal para el usuario */
    font-size: 20px; /* Tamaño un poco más pequeño */
    color: #b5d6a8; /* Color diferenciado para el usuario */
}
.bocadillo {
    position: absolute;
    top: -40px; /* Por encima del jugador */
    left: 50%;
    transform: translateX(-50%);
    background-color: #f0c674; /* Fondo dorado para destacar */
    color: black; /* Texto en negro */
    padding: 5px 10px;
    border-radius: 10px;
    font-size: 14px;
    font-weight: bold;
    visibility: hidden; /* Oculto por defecto */
    opacity: 0; /* Transparente inicialmente */
    transition: opacity 0.3s ease, visibility 0.3s ease;
}

/* Flecha del bocadillo */
.bocadillo::after {
    content: "";
    position: absolute;
    bottom: -5px;
    left: 50%;
    transform: translateX(-50%);
    border-width: 5px;
    border-style: solid;
    border-color: #f0c674 transparent transparent transparent;
}
/* Estilo para el mazo */
.mazo2 {
    position: absolute;
    width: 50px;
    height: 30px;
 /*   background-image: url('../static/img/cartas/zz.png');*/ /* Cambia la ruta por la de tu imagen */
    background-size: cover;
    position: absolute;
    /*transform: rotate(30deg); Aplica el ángulo necesario */
}

.mazo2 img {
    width: 100%;
    height: 100%;
    object-fit: cover;
    border-radius: 5px;
    box-shadow: 0px 4px 8px rgba(0, 0, 0, 0.3);
}

.botones-juego button {
  padding: 10px 20px;
  font-size: 16px;
  border-radius: 8px;
  border: none;
  cursor: pointer;
  background-color: #4CAF50;
  color: white;
  transition: opacity 0.3s;
}

.botones-juego button:disabled {
  background-color: #9E9E9E;
  cursor: not-allowed;
}
.botones-juego {
  display: flex;
  justify-content: center; /* Centrar horizontalmente */
  align-items: center;    /* Centrar verticalmente */
  position: absolute;     /* Para posicionarlos en el centro absoluto de la mesa */
  top: 50%;               /* Centrar verticalmente */
  left: 50%;              /* Centrar horizontalmente */
  transform: translate(-50%, -50%); /* Ajustar el desplazamiento del centro */
  gap: 20px;              /* Espaciado entre botones */
  z-index: 10; /* Asegura que los botones estén por encima de otros elementos */
}

#descartar {
  padding: 10px 20px;
  font-size: 16px;
  background-color: lightgray;
  color: black;
  border: none;
  border-radius: 5px;
  cursor: pointer;
  transition: background-color 0.3s ease;
  pointer-events: none; /* Deshabilita clics por defecto */
  opacity: 0.5; /* Reduce la opacidad para indicar que está inactivo */
}

#descartar:hover {
  background-color: yellowgreen;
}

#descartar.oculto {
  display: none; /* Clase para ocultar el botón */
}
#descartar.activo {
    pointer-events: auto; /* Habilita clics */
    opacity: 1; /* Restaura la opacidad */
}

.mesa-botones {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 10px; /* Mayor espacio entre los botones principales min-height: 70px; */
  margin-top: 0px; /* Espaciado superior */
}

.fila {
  display: flex;
  justify-content: space-around; /* Espaciado igual entre botones */
  width: 100%; /* Usar todo el ancho disponible */
  max-width: 300px; /* Limita el ancho de la fila para que no sea demasiado extensa */
  gap: 20px; /* Espacio adicional entre botones si es necesario */
  margin: 0 auto; /* Centra la fila horizontalmente */
}

.envido-control {
  display: flex;
  gap: 10px; /* Espaciado entre los controles de envido */
  justify-content: center;
  align-items: center; /* Centra verticalmente los botones con el número */
}

button {
  background-color: #1E90FF; /*#F4A261;*/ /* Naranja suave y cálido */
  color: white;
  border: none;
  border-radius: 8px; /* Bordes redondeados para un aspecto amigable */
  padding: 12px 20px; /* Más espacio para hacerlos cómodos */
  font-size: 16px; /* Tamaño de texto legible */
  cursor: pointer;
  transition: background-color 0.4s ease, box-shadow 0.3s ease; /* Transiciones suaves */
}

button:hover {
  background-color: #E76F51; /* Naranja rojizo suave al pasar el ratón */
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.15); /* Sombra ligera */
}

button:active {
  background-color: #D66A50; /* Color más oscuro al hacer clic */
  box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.2); /* Efecto de presionado */
}


#valor-envido {
  font-size: 20px;
  font-weight: bold;
  margin: 0 10px; /* Espaciado entre el número y los botones */
}
.fade-in {
  animation: fadeIn 0.5s ease-in-out;
}

@keyframes fadeIn {
  from {
    opacity: 0;
    transform: translateY(20px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}



	.turno-notificacion {
      position: absolute;
      top: 10px;
      right: 10px;
      background-color: #87ceeb; /* Azul celeste */
      color: #2c3e50; /* Texto oscuro para contraste */
      font-family: 'Arial', sans-serif; /* Fuente limpia y legible */
      font-size: 15px; /* Tamaño del texto más grande */	  
      padding: 10px 15px;
      border-radius: 10px;
	  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3); /* Sombra para destacarlo */	  
      font-size: 14px;
      opacity: 1;
      visibility: visible;
      transition: opacity 0.5s ease, visibility 0.5s ease;
      text-align: center; /* Centra el texto */
      display: inline-block; /* Tamaño ajustado al contenido */
      animation: aparecer 0.5s ease; /* Animación de entrada */	  
    }

    .turno-notificacion.oculto {
      opacity: 0;
      visibility: hidden;
    }

	.turno-label {
	  font-size: 18px;
	  font-weight: bold;
	  text-align: center;
	  margin-bottom: 10px; /* Espaciado estándar */
	  position: absolute; /* Posición absoluta para colocarlo sobre los botones */
	  top: -30px; /* Ajusta según el espacio que necesites */
	  left: 50%; /* Centra horizontalmente */
	  transform: translateX(-50%); /* Compensa el centrado horizontal */
	  z-index: 10; /* Asegura que esté por encima de otros elementos */
	}
	.turno-label.oculto {
		display: none; /* Oculta el elemento */
	}	
	


/* Animación para hacer que el mensaje aparezca suavemente */
@keyframes aparecer {
    from {
        opacity: 0;
        transform: translateY(-10px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

/* Opcional: Cambia el color al pasar el ratón */
.turno-notificacion:hover {
    background-color: #e58e26; /* Naranja suave */
    color: #fff; /* Texto blanco */
}

	
	
   .botoncm:disabled {
		background-color: #ccc;
		cursor: not-allowed;
	}
	.botoncm {
		padding: 10px 20px;
		font-size: 16px;
		cursor: pointer;
		border: 1px solid #000;
		border-radius: 5px;
		background-color: #f0f0f0;
	}
	.botoncm:hover:not(:disabled) {
		background-color: #d0d0d0;
	}
	.bloqueado {
	  pointer-events: none; /* Bloquea interacción */
	  opacity: 0.5; /* Indica visualmente que está deshabilitado */
	  cursor: not-allowed; /* Cambia el cursor al pasar sobre ellos */
	}
	.texto-lance {
	  font-size: 40px;
	  font-weight: bold;
	  color: #ffffff; /* Blanco */
	  text-align: center;
	  margin-bottom: 10px; /* Espacio entre el texto y los botones */
	  animation: fadeIn 0.5s ease-in-out; /* Animación al cambiar */
}

.bocadillo-puntos {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background-color: #E76F51;
  border: 2px solid #007bff; /* Cambia el color para diferenciar */
  border-radius: 12px;
  padding: 20px;
  box-shadow: 0 6px 10px rgba(0, 0, 0, 0.25);
  text-align: center;
  z-index: 1050; /* Asegúrate de que esté encima de otros elementos */
  animation: fadeIn 0.3s ease;
}

.bocadillo-puntos table {
  width: 100%;
  border-collapse: collapse;
}

.bocadillo-puntos th,
.bocadillo-puntos td {
  padding: 10px;
  border: 1px solid #ddd;
  text-align: center;
  font-weight: bold;
}

.bocadillo-puntos th {
  background-color: #007bff;
  color: white;
}

.bocadillo-puntos.oculto {
  display: none;
}

.bocadillo-puntos tbody tr:nth-child(1) {
    background-color: blue;
    color: white; /* Opcional: para que el texto se vea bien */
}

.bocadillo-puntos tbody tr:nth-child(2) {
    background-color: red;
    color: white;
}


@keyframes fadeIn {
  from {
    opacity: 0;
    transform: translate(-50%, -60%);
  }
  to {
    opacity: 1;
    transform: translate(-50%, -50%);
  }
}

#mensaje-central {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
	background-color: #E76F51;
    color: white;
    padding: 20px 40px;
    border-radius: 10px;
    font-size: 1rem;
    font-weight: bold;
    text-align: center;
    z-index: 9999; /* Asegúrate de que esté encima de otros elementos */
    display: none; /* Ocultar por defecto */
}

.mensaje-visible {
    display: block !important;
}

.mensaje-oculto {
    display: none !important;
}

/* Estilos para la ventana emergente */
.popup {
    position: fixed; /* Superposición absoluta */
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.5); /* Fondo oscuro semi-transparente */
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 9999; /* Asegúrate de que esté por encima de todo */
}


.popup.hidden {
    display: none; /* Oculta la ventana emergente por defecto */
}

.popup-content {
    background: #007bff;
    padding: 20px 30px;
    border-radius: 8px;
    text-align: center;
    box-shadow: 0 4px 10px rgba(0, 0, 0, 0.25);
}

.popup-content p {
    font-size: 1.2rem;
    margin-bottom: 20px;
}

.popup-buttons {
    display: flex;
    justify-content: space-around;
    gap: 10px;
}

.popup-buttons .btn {
    padding: 10px 20px;
    font-size: 1rem;
    border: none;
    border-radius: 4px;
    cursor: pointer;
}

.popup-buttons .btn:hover {
    opacity: 0.9;
}

#btn-exit {
    background-color: #dc3545;
    color: #fff;
}

#btn-new-game {
    background-color: #28a745;
    color: #fff;
}


.carta-descartada {
    width: 65px; /* Mantén el tamaño original */
    height: 100px; /* Mantén el tamaño original */
    background-image: url('../static/img/cartas/zz.png');
    background-size: cover;
    border: 1px solid #ccc;
    position: absolute;
    animation: moverAlMonton 1s ease-out forwards;
}

.nueva-carta {
    width: 65px; /* Mantén el tamaño original */
    height: 100px; /* Mantén el tamaño original */
    background-image: url('../static/img/cartas/zz.png');
    background-size: cover;
    border: 1px solid #008cff;
    animation: entrarEnMano 0.5s ease-out forwards;
}

@keyframes moverAlMonton {
    0% {
        transform: translate(0, 0);
        opacity: 1;
    }
    100% {
        transform: translate(-100px, 100px);
        opacity: 0;
    }
}

@keyframes entrarEnMano {
    0% {
        transform: scale(0);
        opacity: 0;
    }
    100% {
        transform: scale(1);
        opacity: 1;
    }
}
#mazo {
    width: 50px;
    height: 70px;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
 /*   background-image: url('../static/img/cartas/zz.png'); */
    background-size: cover;
    border: 1px solid #ccc;
}

.mensaje-jugador {
    position: absolute;
    top: -35px; /* Ajusta la posición sobre el jugador */
    left: 50%; /* Centra horizontalmente con respecto al jugador */
    transform: translateX(-50%); /* Ajusta la posición para que el centro del mensaje coincida */
    background-color: rgba(255, 255, 255, 0.8);
    color: black;
    padding: 5px 10px;
    border-radius: 5px;
    font-size: 14px;
    white-space: nowrap;
    visibility: hidden; /* Oculto por defecto */
    opacity: 0;
    transition: opacity 0.3s ease-in-out;
}

.mensaje-jugador.mostrar {
    visibility: visible;
    opacity: 1;
}

/* Si el mensaje pertenece al jugador principal, lo mostramos a la derecha */
.jugador-1 .mensaje-jugador {
    top: 50%; /* Centra el mensaje verticalmente */
    left: 100%; /* Lo posiciona a la derecha del avatar */
    transform: translateY(-50%); /* Ajusta la posición para que esté alineado */
    white-space: normal; /* Permite que el texto se ajuste si es largo */
    width: auto;
    max-width: 200px; /* Evita que sea demasiado ancho */
}

        /* ----- NUEVO: Estilos para el temporizador ----- */
        .timer-container {
            display: flex;
            align-items: center;
            gap: 5px;
            font-family: Arial, sans-serif;
        }
        /* Oculto por defecto */
        .timer-container.oculto {
            display: none;
        }
        .hourglass {
            font-size: 20px;
            animation: giro 1s linear infinite;
        }
        @keyframes giro {
            0%   { transform: rotate(0deg); }
            50%  { transform: rotate(180deg); }
            100% { transform: rotate(360deg); }
        }
        .countdown {
            font-size: 20px;
            font-weight: bold;
        }



    </style>
</head>
<body>

    <!-- Encabezado -->
<header class="cabecera">
    <h1>
         Musdocemas - Mesa de Juego {{ mesa.nombre.split('_')[1] }} 
        <span class="usuario"> - {{ usuario }} - </span>
		<span class="partida" id="partida"></span>
    </h1>
	<nav>
		<a href="{{ url_for('logout2') }}" class="btn btn-danger">Desconectar</a>
	</nav>	
</header>

    <!-- Contenedor Principal -->
    <div class="contenedor">
        <!-- Mesa de Juego -->

        <div class="mesa-de-juego">
        <!-- Tablero de Puntuación -->
        <p></p>
			<div class="tablero">
			  <table class="puntuacion-tabla">
				<thead>
				  <tr>
					<th>Jugadores</th>
					<th>Puntos</th>
					<th>Juegos</th>
				  </tr>
				</thead>
				<tbody>
				  <tr>
					<td id="pareja1">Pareja 1</td>
					<td id="puntos-pareja1">0</td>
					<td id="juegos-pareja1">0</td>
				  </tr>
				  <tr>
					<td id="pareja2">Pareja 2</td>
					<td id="puntos-pareja2">0</td>
					<td id="juegos-pareja2">0</td>
				  </tr>
				</tbody>
			  </table>
			</div>		<!-- Jugadores -->	
			<div class="turno-notificacion oculto" id="turnoNotificacion">Hola</div>	
			<div class="jugador jugador-1">
				<img src="" alt="Avatar Jugador 1">
				<span class="alias"></span> 
				<!-- Temporizador: Se mostrará cuando sea su turno -->
                <div class="timer-container oculto" id="timer-1">
                    <div class="hourglass">⌛</div>
                    <div class="countdown" id="countdown-1">10</div>
                </div>
				<div class="jugador-principal" id="mensaje-jugador-0"></div>
				<div class="bocadillo"></div>
				<div class="cartas">
				  <div class="carta" draggable="true" id="carta1" data-id="1" alt="Carta 1"></div>
				  <div class="carta" draggable="true" id="carta2" data-id="2" alt="Carta 2"></div>
				  <div class="carta" draggable="true" id="carta3" data-id="3" alt="Carta 3"></div>
				  <div class="carta" draggable="true" id="carta4" data-id="4" alt="Carta 4"></div>
				</div>	
			</div>
			<div class="jugador jugador-2">
				<img src="" alt="Avatar Jugador 2">
				<span class="alias"></span>
                <!-- Temporizador para jugador 2 -->
                <div class="timer-container oculto" id="timer-2">
                    <div class="hourglass">⌛</div>
                    <div class="countdown" id="countdown-2">10</div>
                </div>
				<div class="mensaje-jugador" id="mensaje-jugador-1"></div>
				<div class="bocadillo"></div>
				<div class="cartas">
					<div class="carta carta-oculta"></div>
					<div class="carta carta-oculta"></div>
					<div class="carta carta-oculta"></div>
					<div class="carta carta-oculta"></div>
				</div>
			</div>
			<div class="boton-repartir-container">
				<button id="btn-repartir" onclick="repartirCartas()">Repartir</button>
			</div>	
			<div class="mesa-juego">
			  <!-- Otros elementos de la mesa 
			  <div id="turnoJugador" class="turno-label"></div>-->
			  <div class="botones-juego" id="botones-juego" style="display: none;">
				<button id="btn-corto" class="botoncm" onclick="accionCorto()">Corto</button>
				<button id="btn-mus" class="botoncm" onclick="accionMus()">Mus</button>
			  </div>
			</div>

			<div class="mesa-botones" style="display: none;">
			  <div id="texto-lance" class="texto-lance"></div>
			  <div class="fila">
			    <button id="ordago" class="botines">¡Órdago!</button>
				<button id="ver" class="botines">Veo</button>
				<button id="paso" class="botines">Paso</button>
			  </div>
			  <div class="envido-control">
				<button id="decrementar-envido" class="botines">-</button>
				<span id="valor-envido">2</span>
				<button id="incrementar-envido" class="botines">+</button>
				<button id="envidar" class="botines">Envido</button>
			  </div>
			</div>
			<div id="mensaje-central" class="mensaje-oculto"></div>
			<div id="bocadillo-puntos" class="bocadillo-puntos oculto">
			  <table>
				<thead>
				  <tr>
					<th></th>        
					<th>Grande</th>
					<th>Chica</th>
					<th>Pares</th>
					<th>Juego</th>
				  </tr>
				</thead>
				<tbody>
				  <tr>
					<td id="nombre-pareja1">Pareja 1</td>
					<td id="puntos-grande-pareja1">0</td>
					<td id="puntos-chica-pareja1">0</td>
					<td id="puntos-pares-pareja1">0</td>
					<td id="puntos-juepu-pareja1">0</td>
				  </tr>
				  <tr>
					<td id="nombre-pareja2">Pareja 2</td>
					<td id="puntos-grande-pareja2">0</td>
					<td id="puntos-chica-pareja2">0</td>
					<td id="puntos-pares-pareja2">0</td>
					<td id="puntos-juepu-pareja2">0</td>
				  </tr>
				</tbody>
			  </table>
			</div>

			<button id="descartar" style="display: none;">Descartar</button>
			<!--<button id="descartar" style="display: none;" onclick="descartarCartas()">Descartar</button>
			<div id="mazo" class="mazo">
				<img src="../static/img/cartas/reversoazul3mazo.png" alt="Mazo de cartas">
			</div>-->
			<div class="jugador jugador-3">
				<img src="" alt="Avatar Jugador 3">
				<span class="alias"></span>
                <!-- Temporizador para jugador 3 -->
                <div class="timer-container oculto" id="timer-3">
                    <div class="hourglass">⌛</div>
                    <div class="countdown" id="countdown-3">10</div>
                </div>
				<div class="mensaje-jugador" id="mensaje-jugador-2"></div>
				<div class="bocadillo"></div>
				<div class="cartas">
					<div class="carta carta-oculta"></div>
					<div class="carta carta-oculta"></div>
					<div class="carta carta-oculta"></div>
					<div class="carta carta-oculta"></div>
				</div>
			</div>
			<div class="jugador jugador-4">
				<img src="" alt="Avatar Jugador 4">
				<span class="alias"></span>
                <!-- Temporizador para jugador 4 -->
                <div class="timer-container oculto" id="timer-4">
                    <div class="hourglass">⌛</div>
                    <div class="countdown" id="countdown-4">10</div>
                </div>
				<div class="mensaje-jugador" id="mensaje-jugador-3"></div>
				<div class="bocadillo"></div>
				<div class="cartas">
					<div class="carta carta-oculta"></div>
					<div class="carta carta-oculta"></div>
					<div class="carta carta-oculta"></div>
					<div class="carta carta-oculta"></div>
				</div>
			</div>
        </div>
        <!-- Chat de Juego -->
        <div class="chat">
            <h3>Chat de la Mesa {{ mesa.nombre.split('_')[1] }}</h3>
			<div id="chat-box" class="chat-box">
				<!-- Aquí se mostrarán los mensajes del chat -->
			</div>
            <div class="chat-input">
                <input type="text" placeholder="Escribe un mensaje..." id="chat-message_mesa">
                <button onclick="sendMessage()">Enviar</button>
            </div>
        </div>	

 </div>
 
 <div id="popup" class="popup hidden">
    <div class="popup-content">
        <p id="popup-message">Partida finalizada. Ha ganado la pareja Jugador1 - Jugador3.</p>
        <div class="popup-buttons">
            <button id="btn-exit" class="btn">Salir</button>
            <button id="btn-new-game" class="btn">Nueva partida</button>
        </div>
    </div>
</div>

	<script>
		const socket = io();
		
		const mesa = {{ mesa|tojson }};
		
		// Obtener el ID de la mesa desde la plantilla
		const mesaroom = "{{ mesa.nombre }}";
		const userroom = "{{ usuario }}"; 
		// Unirse a la sala de la mesa
		socket.emit('join_mesa', { mesa_id: mesaroom, username: userroom });
				
		// Define las posiciones relativas (abajo, izquierda, arriba, derecha)
		const posiciones = ["jugador-1", "jugador-2", "jugador-3", "jugador-4"];
		// Reorganizar las posiciones según el usuario
		const reorganizedJugadores = [];
		const reorganizedAvatares = [];
	    const cartasOriginales = [];
		
		const bot = mesa.bot_activo[[mesa.turno_actual]];
		const owner = mesa.owner;
		// Funcion principal que carga la mesa con los datos de jugadores
		
		document.addEventListener("DOMContentLoaded", () => {
			const mesa = {{ mesa|tojson }}; // Datos de la mesa desde el servidor
			ocultarMesaBotones();
		// Lógica para saber si un jugador se ha reconectado:	
			//const accion = mesa.accion;
			//if ((mesa.puntos[0] == 0) && (mesa.puntos[1] == 0) && (mesa.juegos[0] == 0) && (mesa.juegos[1] == 0)) {
			console.log("Usuario ", userroom, " entra por reconexión a la mesa ", mesaroom, " Estado partida: ", mesa.estado_partida);
			//alert(" Inicio mesa_juego. Estado partida: " + mesa.estado_partida);
			//if ( mesa.estado_partida === "Repartir" ) {
				actualizarMesa(mesa);
			/*} else {
			  // aqui se reconecta el Jugador
				const btnRepartir = document.getElementById("btn-repartir");
				btnRepartir.classList.add("oculto");							
				actualizarMesa(mesa);
				repartirCartasCliente(mesa.manos, userroom);						
				// aqui
				if ( mesa.estado_partida === "Descartar" ) {
					ocultarBotones();	
					iniciarPeriodoDescarte(jugadores[mesa.turno_actual])				 
				}
				limpiarHablado();
				if (( mesa.estado_partida === "Cortar" ) || ( mesa.estado_partida === "Jugar" )) {				
					// Si le toca al bot decide el servidor. Solo llama el owner de la mesa para que sea una vez.
					if ((bot === true) && (owner === userroom)) {
						alert ("BOT reconexion. Va a llamar a BOT_tratar_juego 1 con jugador: " + jugadores[mesa.turno_actual]);
						socket.emit('BOT_tratar_juego', { mesa_id: mesaId, jugadorTurno: jugadores[mesa.turno_actual] });
					}
					const userIndex = jugadores.findIndex(jugador => jugador === userroom);
					if (mesa.turno_actual === userIndex) {
						mostrarMesaBotones(mesa.apuesta_actual);
					} else {
						bloquearMesaBotones();
					}
				}
				if ( mesa.estado_partida === "Mus" ) {
					if ((bot === true) && (owner === userroom)) {
						alert ("BOT reconexion. Va a llamar a BOT_tratar_mus_corto con jugador: " + jugadores[mesa.turno_actual]);
						socket.emit('BOT_tratar_mus_corto', { mesa_id: mesaroom, jugadorTurno: jugadores[mesa.turno_actual] });
					} else {
						mostrarBotones(jugadores[mesa.turno_actual]);	
					}
				}	
			} */
		});


		document.addEventListener('keydown', function(event) {
		  // Comprobamos si se pulsa F5
		  if (event.key === 'F5' || event.keyCode === 116) {
			event.preventDefault(); // Prevenir la recarga de la página
			alert("Presionar F5 interrumpirá el juego. No se recargará la página.");
		  }
		});
		
		//Refrescar la mesa:
		function actualizarMesa(mesa) {
			const username = "{{ usuario }}"; // Usuario actual desde Flask
			const jugadores = mesa.jugadores; // Lista de jugadores desde Python
			const avatares = mesa.avatares; // Lista de avatares desde Python
			const mano = mesa.mano; // Índice del jugador que es mano
			const manoJugador = jugadores[mano]; // Nombre del jugador que es mano
			const jugadorTurno = manoJugador;
			let partida = "";
			if (mesa.juegos_vaca === 1) {
				partida = "Partida a 1 juego de " + mesa.puntos_juego;
			} else {
				partida = "Partida a " + mesa.juegos_vaca + " juegos de " + mesa.puntos_juego;
			}
			document.getElementById('partida').innerHTML = '<span style="font-size: 14px;">' + partida + '</span>';
			
			console.log("ACTUALIZAR MESA:", mesa, "JugadorTurno en ActualizarMesa: ", jugadorTurno);
			let reparte = 0;
			if (mano === 0) {
				reparte = 3;
			} else {
				reparte = mano - 1;
			}
			const reparteJugador = jugadores[reparte];
			//console.log("Actualizar mazo desde actualizarMesa. JugadorAnterior: ", reparteJugador, " valor: ", reparte);
			//actualizarMazo(reparteJugador, reparte);
			// Encuentra la posición del usuario en el array
			const userIndex = jugadores.findIndex(jugador => jugador === username);

			if (userIndex === -1) {
				console.error("El usuario no está en la mesa.");
				return;
			}

			// Define las posiciones relativas (abajo, izquierda, arriba, derecha)
			//const posiciones = ["jugador-1", "jugador-2", "jugador-3", "jugador-4"];

			for (let i = 0; i < jugadores.length; i++) {
				const newIndex = (i - userIndex + jugadores.length) % jugadores.length;
				reorganizedJugadores[newIndex] = jugadores[i];
				reorganizedAvatares[newIndex] = avatares[i];
			}

			// Actualiza el DOM con los datos reorganizados
			reorganizedJugadores.forEach((jugador, index) => {
				//alert("Pulsa MUS y entra por reorganizedJugadores.forEach");
				const position = posiciones[index];
				const jugadorElement = document.querySelector(`.${position}`);
				console.log("jugadorelement reorganizedJugadores: ", jugadorElement, " position: ", position);

				if (jugadorElement) {
					const avatarElement = jugadorElement.querySelector("img");
					const aliasElement = jugadorElement.querySelector(".alias");

					// Actualiza avatar y alias
					avatarElement.src = reorganizedAvatares[index] || "../static/img/avatares/avatar.png";
					aliasElement.textContent = jugador || "Vacío";

					// Resalta el jugador que es mano
					if (jugador === manoJugador) {
						jugadorElement.classList.add("mano");
						console.log("jugadorelement bocadillo: ", jugadorElement, " position: ", position);
						// Mostrar mensaje "Soy mano"
						//mostrarBocadillo(jugadorElement, "Soy mano");
						let index2 = 0;
						if (index === 0) { index2 = 3; } else { index2 = index - 1; }
						const position2 = posiciones[index2];
						const jugadorElement2 = document.querySelector(`.${position2}`);
						//mostrarBocadillo(jugadorElement2, "Reparto");
						//mostrarHablado(index2, "Reparte ");
						mostrarBocadillo2(index2, "Reparto");
						//mostrarHablado(index, "Es mano ");
						mostrarBocadillo2(index, "Soy mano");
						avatarElement.style.animation = "none";
						setTimeout(() => {
							avatarElement.style.animation = ""; // Reactiva la animación
						}, 10);
					} else {
						jugadorElement.classList.remove("mano");
					}
				}
			});
		inicializarPuntuacion(mesa);
		}

		function repartirCartasCliente(manos, usuario) {
			// Encuentra las cartas del usuario conectado
			const cartasJugador = manos[usuario];
			
			if (!cartasJugador) {
				console.error(`No se encontraron cartas para el usuario ${usuario}`);
				return;
			}

			// Encuentra el div del jugador conectado
			const jugadorDiv = Array.from(document.querySelectorAll('.jugador')).find(div => {
				const alias = div.querySelector('.alias').textContent;
				return alias === usuario; // Coincide con el jugador conectado
			});

			if (!jugadorDiv) {
				console.error(`No se encontró el contenedor para el usuario ${usuario}`);
				return;
			}

			// Limpiar las cartas actuales del jugador conectado
			const cartasDiv = jugadorDiv.querySelector('.cartas');
			cartasDiv.innerHTML = '';

			// Asignar las cartas al jugador conectado
			cartasJugador.forEach(carta => {
				const cartaElement = document.createElement('div');
				cartaElement.classList.add('carta');

				// Mostrar la carta real para el jugador conectado
				const rutaImagen = `../static/img/cartas/${carta}.png`;
				cartaElement.style.backgroundImage = `url(${rutaImagen})`;
				cartaElement.style.backgroundSize = 'cover';
				cartaElement.style.backgroundPosition = 'center';

				cartasDiv.appendChild(cartaElement);
			});

			console.log(`Cartas repartidas al usuario ${usuario}:`, cartasJugador);
		}

		  /**
		   * Inicia el temporizador para un jugador.
		   * @param {string} timerId - El ID del contenedor del timer.
		   * @param {string} countdownId - El ID del elemento donde se muestra el tiempo.
		   * @param {number} duration - Duración en segundos.
		   * se llama con por ejemplo al jugador 2 startTimer("timer-2", "countdown-2", 10)
		   */ 
		function startTimer(timerId, countdownId, duration) {
			 var timerContainer = document.getElementById(timerId);
			 var countdownEl = document.getElementById(countdownId);
			 var timeLeft = duration;
			  // Mostrar el timer
			 timerContainer.classList.remove('oculto');
			 countdownEl.textContent = timeLeft;
			  
			 var timerInterval = setInterval(function() {
				 timeLeft--;
				 countdownEl.textContent = timeLeft;
				 if (timeLeft <= 0) {
					clearInterval(timerInterval);
					// Ocultar el timer al agotarse el tiempo
					 timerContainer.classList.add('oculto');
					 // Aquí puedes llamar a la función para la jugada automática del bot
					 alert("Tiempo agotado. El bot hace su jugada.");
				}
			}, 1000);
		}
		
		function mostrarBocadillo(jugadorElement, mensaje) {
			//alert("Entra en mostrar bocadillo. ");
			const bocadillo = jugadorElement.querySelector(".bocadillo");
			bocadillo.textContent = mensaje; // Escribe el mensaje en el bocadillo
			bocadillo.style.visibility = "visible";
			bocadillo.style.opacity = "1";

			// Oculta el bocadillo después de 3 segundos
			setTimeout(() => {
				bocadillo.style.opacity = "0";
				bocadillo.style.visibility = "hidden";
			}, 4000);
		}	

		function mostrarBocadillo2(indice, mensaje) {
			//alert("Entra en mostrar bocadillo.2 ");
			if (indice === -1) {
				console.log("En mostrarBocadillo2 el índice es -1.");
				return;
			}
			const posiciones = ["jugador-1", "jugador-2", "jugador-3", "jugador-4"];			
			const position = posiciones[indice];
			console.log("mostrarBocadillo2. Posicion: ", position, " indice: ", indice, " mensaje: ", mensaje);
			const jugadorElement = document.querySelector(`.${position}`);
			const bocadillo = jugadorElement.querySelector(".bocadillo");
			bocadillo.textContent = mensaje; // Escribe el mensaje en el bocadillo
			bocadillo.style.visibility = "visible";
			bocadillo.style.opacity = "1";

			// Oculta el bocadillo después de 3 segundos
			setTimeout(() => {
				bocadillo.style.opacity = "0";
				bocadillo.style.visibility = "hidden";
			}, 4000);
		}			

		socket.on('mesa_actualizada', function(mesa) {
			console.log('Mesa actualizada:', mesa);
			console.log("Recibidos nuevos datos de la mesa:", mesa);
			actualizarMesa(mesa);
			console.log("Parada para ver mesa: ");
		});

		// Actualizar la vista de la mesa con los nuevos datos
		socket.on('jugadores_actualizados', function(mesa) {
			const jugadores = document.querySelectorAll('.jugador');
			mesa.jugadores.forEach((jugador, index) => {
				const jugadorElement = jugadores[index];
				if (jugador) {
					jugadorElement.querySelector('img').src = jugador.avatar;
					jugadorElement.querySelector('span').textContent = jugador.username;
				} else {
					jugadorElement.querySelector('img').src = "../static/img/avatar.png";
					jugadorElement.querySelector('span').textContent = "Vacante";
				}
			});
		});


		// Obtener el ID de la mesa desde la plantilla
		const mesaId = "{{ mesa.nombre }}";
		const username = "{{ usuario }}"; // Reemplaza con el nombre real del usuario
			//alert("Mesa_nombre: " + mesaId);
		// Unirse a la sala de la mesa
		//socket.emit('join_mesa', { mesa_id: mesaId, username: username });

		window.onload = function() {
			const username = "{{ usuario }}";
			const mesaId = "{{ mesa.nombre }}";
			//alert("Mesa.nombre: " + mesaId);
			// Redimensionar la ventana a un tamaño específico
			//alert("Va a redimensionar la pantalla");
			// Solo funciona en ventanas abiertas con window.open
			if (window.outerWidth !== 1024 || window.outerHeight !== 768) {
				window.resizeTo(1524, 808);
			}
			// Opcionalmente, mover la ventana al centro
			const x = (window.screen.availWidth - 1524) / 2;
			const y = (window.screen.availHeight - 808) / 2;
			window.moveTo(x, y);
			//socket.emit('join_mesa', { username: username, mesa_id: mesaId });	
		
		};

	
		// Escuchar el evento 'mensaje_mesa' para mostrar los mensajes en el chat
		socket.on('mensaje_mesa', function(data) {
			console.log("Entra en mensaje_mesa con data:", data);
			//alert("Entra en mensaje mesa");
			const chatBox = document.getElementById('chat-box');
			const messageElement = document.createElement('div');
			messageElement.classList.add('chat-mensaje');
			messageElement.innerHTML = `<strong>${data.username}:</strong> ${data.msg}`;
			chatBox.appendChild(messageElement);
			chatBox.scrollTop = chatBox.scrollHeight; // Desplaza el chat hacia abajo
		});

		// Detectar la tecla Enter en el campo de texto del chat
		document.getElementById('chat-message_mesa').addEventListener('keypress', function (event) {
			if (event.key === 'Enter') { // Verifica si se pulsó la tecla Enter
				event.preventDefault(); // Previene el comportamiento por defecto (nueva línea)
				sendMessage(); // Llama a la función para enviar el mensaje
			}
		});
		// Función para enviar mensajes al servidor
		window.sendMessage = function() {
			const username = "{{ usuario }}";
			const mesaId = "{{ mesa.nombre }}";
			const message = document.getElementById('chat-message_mesa').value.trim();
			if (message) {
				console.log("Enviando mensaje:", message);
			    //alert("Va a hacer emit del mensaje: " + message);
				socket.emit('mensaje_chat_mesa', { username: username, message: message, mesa_id: mesaId });
				document.getElementById('chat-message_mesa').value = ''; // Limpiar el campo de entrada
			}
		};

        /*socket.on('chat_message_mesa', function(data) {
            const chatBox = document.getElementById('chat-box');
            const messageElement = document.createElement('p');
            messageElement.textContent = `${data.username}: ${data.message}`;
            chatBox.appendChild(messageElement);
            chatBox.scrollTop = chatBox.scrollHeight;
		});	*/	
		//==========================================================================================
		// Funcion para el reparto de cartas
		//==========================================================================================
		function repartirCartas() {
			const mesaId = "{{ mesa.nombre }}"; // Obtenemos el ID de la mesa desde la plantilla
			limpiarHablado();
			socket.emit('repartir_cartas', { mesa_id: mesaId });
			const mano = mesa.mano;
			const valor = (mano - 1 + 4) % 4;
			const jugadorAnterior = jugadores[valor];
			// Actualizar el repartidor y mover el mazo
			//console.log("Actualizar mazo desde repartirCartas. JugadorAnterior: ", jugadorAnterior, " valor: ", valor);
			//actualizarMazo(jugadorAnterior, valor);		    
			
			// Enviar mensaje al chat informando
			const mensaje2 = "Repartiendo cartas...";
			socket.emit('mensaje_chat_mesa', { mesa_id: mesaId, username: 'Docemas', message: mensaje2 });
			
			// Ocultar el botón una vez que se pulsa
			const btnRepartir = document.getElementById("btn-repartir");
			btnRepartir.classList.add("oculto");
			//const jugadores = mesa.jugadores;
			//const mano = mesa.mano;
			//const jugadorMano = jugadores[mano];
			//console.log("En repartir cartas el mano es : ", jugadorMano);
			// Actualizar los botones de Corto y Mus para que solo el jugador "mano" los tenga activos
			//mostrarBotones(jugadorMano);
			//const botonesJuego = document.getElementById('botones-juego');
			//botonesJuego.style.display = 'flex'; // Mostrar los botones
		}

		//*************************************************************************
		//   AQUI ES DONDE SE REPARTEN LAS CARTAS ENTRE LOS 4 JUGADORES
		//*************************************************************************
		// Escuchar el evento 'cartas_repartidas' para mostrar las cartas en la interfaz
		socket.on('cartas_repartidas', function(data) {
		
			// Aquí se reparte las cartas al comenzar la partida a los 4 jugadores.
		
			if (data.mesa_id !== "{{ mesa.nombre }}") {
				console.log("No coinciden los datos de la mesa: " + data.mesa_id);
				return; // Verificamos que es la mesa actual
			}			
			const manos = data.manos;
			const mano = data.mano;
			const bot = data.bot;
			const owner = data.owner;
			const jugadorCliente = "{{ usuario }}";			

			//alert("Entra por cartas_repartidas y Asignar las cartas a cada jugador");
			console.log("cartas_repartidas. Manos: ", manos, " bot: ", bot, " mano: ", mano);

			// Ocultar el botón repartir y habilita corto y mus una vez que se entra desde el servidor
			const btnRepartir = document.getElementById("btn-repartir");
			btnRepartir.classList.add("oculto");

			const jugadores = mesa.jugadores;
			const jugadorMano = jugadores[mano];
			console.log("cartas_repartidas.El mano es : ", jugadorMano);
			
			//const botonesJuego = document.getElementById('botones-juego');
			//botonesJuego.style.display = 'flex'; // Mostrar los botones
			//alert("Actualiza los botones");

			Object.keys(manos).forEach((jugador) => {
				const cartas = manos[jugador];

				// Encuentra el div correspondiente al jugador actual
				const jugadorDiv = Array.from(document.querySelectorAll('.jugador')).find(div => {
					const alias = div.querySelector('.alias').textContent;
					return alias === jugador;
				});
								
				if (jugadorDiv) {
					// Limpiar las cartas actuales
					const cartasDiv = jugadorDiv.querySelector('.cartas');
					cartasDiv.innerHTML = '';

					// Asignar las cartas
					cartas.forEach(carta => {
						const cartaElement = document.createElement('div');
						cartaElement.classList.add('carta');

						// Mostrar las cartas del jugador conectado y ocultar las de los demás
						let rutaImagen;
						if (jugador === "{{ usuario }}") {
							rutaImagen = `../static/img/cartas/${carta}.png`; // Mostrar la carta real
						} else {
							//rutaImagen = `../static/img/cartas/${carta}.png`; // Mostrar la carta real
							rutaImagen = `../static/img/cartas/zz.png`; // Mostrar la carta bocabajo
						}

						// Crear la ruta de la imagen
						//const rutaImagen = `/static/img/cartas/${carta}.png`;
						
						cartaElement.style.backgroundImage = `url(${rutaImagen})`;
						cartaElement.style.backgroundSize = 'cover';
						cartaElement.style.backgroundPosition = 'center';

						cartasDiv.appendChild(cartaElement);
					});
				}
			});
			//alert ("BOT cartas_repartidas. Va a llamar a BOT_tratar_mus_corto con jugador: " + jugadorMano); 
			if ((bot === true) && (owner === jugadorCliente)) {
				console.log ("BOT cartas_repartidas. Va a llamar a BOT_tratar_mus_corto con jugador: " + jugadorMano);
				socket.emit('BOT_tratar_mus_corto', { mesa_id: mesaId, jugadorTurno: jugadorMano });
			} else {
				mostrarBotones(jugadorMano);
			}
		});

		function inicializarPuntuacion(mesa) {
			const jugadores = mesa.jugadores;
			// Definir los equipos y jugadores
			const equipos = {
				azul: [jugadores[0], jugadores[2]], // Jugadores del equipo azul
				rojo: [jugadores[1], jugadores[3]]  // Jugadores del equipo rojo		
			};

			const pareja1 = `${truncarNombre(jugadores[0])} - ${truncarNombre(jugadores[2])}`;
			const pareja2 = `${truncarNombre(jugadores[1])} - ${truncarNombre(jugadores[3])}`;	

		  // Actualizar el HTML
			document.getElementById("pareja1").textContent = pareja1;
			document.getElementById("pareja2").textContent = pareja2;
		  // Inicializar los puntos y juegos
			actualizarPuntuacion("pareja1", mesa.juegos[0], mesa.puntos[0]);
			actualizarPuntuacion("pareja2", mesa.juegos[1], mesa.puntos[1]);		  
			// Asignar colores al marcador
			document.getElementById('pareja1').classList.add('equipo-azul');
			document.getElementById('pareja2').classList.add('equipo-rojo');

			document.querySelectorAll('.alias').forEach(alias => {
				const nombreJugador = alias.textContent.trim();
				if (equipos.azul.includes(nombreJugador)) {
					alias.classList.add('equipo-azul');
					alias.classList.remove('equipo-rojo'); // Elimina clases previas, si las hubiera
				} else if (equipos.rojo.includes(nombreJugador)) {
					alias.classList.add('equipo-rojo');
					alias.classList.remove('equipo-azul'); // Elimina clases previas, si las hubiera
				}
			});
		}
		
		// Función para truncar los nombres a los 2 primeros y 2 últimos caracteres
		function truncarNombre(nombre) {
		  if (nombre.length <= 4) {
			return nombre; // Si el nombre tiene 4 caracteres o menos, se devuelve tal cual
		  }
		  return nombre.substring(0, 3); // Obtiene los 3 primeros caracteres del Alias
		 // return nombre.substring(0, 1) + nombre.substring(nombre.length - 2); // Combina los primeros 1 y los últimos 2 caracteres
		}

		// Función para actualizar puntos y juegos
		function actualizarPuntuacion(parejaId, juegos, puntos) {
		  document.getElementById(`juegos-${parejaId}`).textContent = juegos;
		  document.getElementById(`puntos-${parejaId}`).textContent = puntos;
		}

		//===========================================================
		// LOGICA PARA DETERMINAR SI TODOS SE DAN MUS O ALGUIEN CORTA
		//===========================================================

		document.addEventListener('DOMContentLoaded', () => {
		  // Lista de jugadores
		  //const jugadores = ['Gordiano1', 'Gordiano10', 'Gordiano11', 'Gordiano12'];
		  const jugadores = mesa.jugadores;
		  let indiceTurno = mesa.turno_actual; // Índice del jugador 
		  // Referencias a elementos
		  const btnCorto = document.getElementById('btn-corto');
		  const btnMus = document.getElementById('btn-mus');
		  const botonesJuego = document.getElementById('botones-juego');


		  // Acción al pulsar "Corto"
		  window.accionCorto = function () {
			const mesaId = "{{ mesa.nombre }}";
			//alert("Se corta el MUS");
			jugadorTurno = jugadores[indiceTurno];
			const jugadorCorto = window.username || "desconocido";
			socket.emit('tratar_corto', { mesa_id: mesaId, jugadorTurno: jugadorTurno, indiceTurno: indiceTurno, jugadorCorto: jugadorCorto });
		  };

		// Acción al pulsar "Mus"
		window.accionMus = function () {
			const mesaId = "{{ mesa.nombre }}";

			console.log("Accion MUS algiuen ha pulsado mus");
			// Emitir evento para procesar la acción en el servidor
			socket.emit('tratar_mus', { mesa_id: mesaId });
		};
 
		 // Escuchar la actualización de turno y contador desde el servidor
		socket.on('actualizar_mus', function (data) {
			musContador = data.musContador; // Actualizar el contador de "Mus" desde el servidor
			indiceActual = data.indiceActual;   // Actualizar el índice del turno desde el servidor
			jugadorActual = data.jugadorActual;
			const jugadorCliente = "{{ usuario }}";
			const mesaId = "{{ mesa.nombre }}";
			const bot = data.bot;
			const owner = data.owner;
			let anterior = indiceActual;
			if (anterior === 0) { anterior = 3; } else { anterior -= 1; }
			//turnoJugador = jugadores[indiceActual];
			jugadorAnterior = jugadores[anterior];
			
			console.log("En actualizar_mus, jugadorAnterior: ", jugadorAnterior, " indice anterior: ", anterior, " Jugador Actual: ", jugadorActual, " indiceActual: ", indiceActual);
			console.log("En actualizar_mus, reorganizedJugadores: ", reorganizedJugadores);

			// Calcular el índice de mano relativo en la lista reorganizada
			const turnoJugadorIdx = reorganizedJugadores.findIndex(jugador => jugador === jugadorAnterior);	
			//mostrarBocadillo2(turnoJugadorIdx, "Mus");
			mostrarHablado(turnoJugadorIdx, "Mus");
			ocultarBotones();
			//console.log("ReorganizedJugadores en MUS para {{ usuario }} : ", reorganizedJugadores);
			//console.log(`Turno actualizado: ${data.jugadorActual} (${indiceMano})`);
			//console.log(`Mus Contador: ${musContador}`);
			//console.log(`Mus Contador: ${musContador}, Turno: ${jugadores[indiceMano]}`);

			//En el caso de que sea un bot, se descarta desde el servidor
			console.log ("BOT actualizar_mus. Va a llamar a BOT_tratar_mus_corto con jugador: " + jugadorActual, " contador: ", musContador);
			if (musContador < 4) { 
				if ((bot === true) && (owner === jugadorCliente)) {
					socket.emit('BOT_tratar_mus_corto', { mesa_id: mesaId, jugadorTurno: jugadorActual });
				} else {
					if (jugadorActual === jugadorCliente) {
						mostrarBotones(jugadorActual);
					} else {
						ocultarBotones();
					}
				}
			}
			
			if (musContador === 4) { 
				//limpiarHablado();
				const turnoJugadorIdx = reorganizedJugadores.findIndex(jugador => jugador === jugadorActual);	
				console.log("Jugador turno es: ", jugadorActual, " indice reorganiced es: ", turnoJugadorIdx);
				mostrarHablado(turnoJugadorIdx, "Mus");
				resaltarManoDescarte(turnoJugadorIdx);
				ocultarBotones();
				console.log ("BOT actualizar_mus. Contador = 4. Va a llamar a tratar_descartar con jugador: " + jugadorActual);				
				if ((bot === true) && (owner === jugadorCliente)) {
					socket.emit('BOT_tratar_descartar', { mesa_id: mesaId, jugadorTurno: jugadorActual });
				}else {
					iniciarPeriodoDescarte(jugadorActual);
				}
			}
		});
		});
//********************
		function resaltarMano(manoJugadorIdx) {
			const manoJugador = reorganizedJugadores[manoJugadorIdx];
			//alert("ManoJugador: " + manoJugador);
		    reorganizedJugadores.forEach((jugador, index) => {
			const position = posiciones[index];
			const jugadorElement = document.querySelector(`.${position}`);
			let index2 = 0;
			if (index === 0) { index2 = 3; } else { index2 = index - 1; }
			const position2 = posiciones[index2];
			const jugadorElement2 = document.querySelector(`.${position2}`);
			//console.log("resaltarMano jugadorelement: ", jugadorElement);
			if (jugadorElement) {
			  const avatarElement = jugadorElement.querySelector("img");
			  const aliasElement = jugadorElement.querySelector(".alias");
			  //alert("ManoJugador desde py: " + manoJugador + " jugador: " + jugador);
			
			  if (jugador === manoJugador) {
				// Resaltar al nuevo "mano"
			//alert("position: " + position + "   position2: " + position2);
			//alert("index: " + index + "  index2: " + index2);
				//mostrarBocadillo(jugadorElement, "Soy mano");
				//mostrarBocadillo(jugadorElement2, "Reparto");		
				jugadorElement.classList.add("mano");
				aliasElement.style.color = "yellow"; // Resaltar el nombre
				avatarElement.style.border = "4px solid yellow"; // Resaltar el avatar
				avatarElement.style.animation = "none";
				setTimeout(() => {
				  avatarElement.style.animation = ""; // Reactivar animación
				}, 10);
			  } else {
				// Normalizar al resto
				jugadorElement.classList.remove("mano");
				aliasElement.style.color = "";   // Color por defecto
				avatarElement.style.border = ""; // Borde por defecto
			  }
			}
		  });
		}

		function resaltarManoDescarte(manoJugadorIdx) {
			// Obtener el nombre del jugador que es mano desde la lista original reorganizada
			//const manoJugador = reorganizedJugadores[manoJugadorIdx]; 
			const manoJugador = reorganizedJugadores[manoJugadorIdx];
			console.log("ReorganizedJugadores resaltar para ", manoJugador, " es: ", reorganizedJugadores);
			if (!manoJugador) {
				console.error("No se encontró al jugador mano en la lista reorganizada.");
				return;
			}
			console.log("Indice del jugador: ", manoJugadorIdx, " Valor en reorganized: ", manoJugador);
			// Iterar sobre los jugadores reorganizados para resaltar al jugador correcto
			reorganizedJugadores.forEach((jugador, index) => {
				const position = posiciones[index];
				const jugadorElement = document.querySelector(`.${position}`);

				if (jugadorElement) {
					const avatarElement = jugadorElement.querySelector("img");
					const aliasElement = jugadorElement.querySelector(".alias");

					if (jugador === manoJugador) {
						// Resaltar al nuevo "mano"
						console.log("jugador: ", jugador, " Jugador mano en reorganized ", manoJugador);
						jugadorElement.classList.add("mano");
						aliasElement.style.color = "yellow"; // Resaltar el nombre
						avatarElement.style.border = "4px solid yellow"; // Resaltar el avatar
						avatarElement.style.animation = "none";
						setTimeout(() => {
							avatarElement.style.animation = ""; // Reactivar animación
						}, 10);
					} else {
						// Normalizar al resto
						jugadorElement.classList.remove("mano");
						aliasElement.style.color = ""; // Color por defecto
						avatarElement.style.border = ""; // Borde por defecto
					}
				}
			});
		}


		
		function actualizarMazo(jugadorAnterior, reparte) {
			const mesaElement = document.querySelector('.mesa');
			const mazoElement = document.getElementById('mazo');
			const turnoJugadorIdx = reorganizedJugadores.findIndex(jugador => jugador === jugadorAnterior);	
			//alert("Valor de reparte: " + reparte);
			// Define posiciones relativas para cada jugador
			//console.log("Reparte: ", jugadorAnterior, " Posición del mazo. 0 arriba, 1 derecha, 2 abajo, 3 izquierda: ", turnoJugadorIdx);
			const posiciones = {
				0: { top: '70%', left: '60%' }, // Mano arriba
				1: { top: '25%', left: '79%' }, // Mano a la derecha
				2: { top: '70%', left: '15%' }, // Mano a la izquierda Ok
				3: { top: '7%', right: '57%' } // Mano abajo (en realidad arriba)
			};
			// Asegúrate de limpiar estilos anteriores
			mazoElement.style.top = posiciones[turnoJugadorIdx]?.top || '';
			mazoElement.style.left = posiciones[turnoJugadorIdx]?.left || '';
			mazoElement.style.right = posiciones[turnoJugadorIdx]?.right || '';
			mazoElement.style.bottom = posiciones[turnoJugadorIdx]?.bottom || '';
		}

	</script>
</body>
	<script>
	
		//==================================================
		// LOGICA PARA SELECCIONAR LAS CARTAS DE DESCARTE
		//==================================================
		let periodoDescarte = false; // Inicialmente no estamos en el periodo de descarte
		
		document.addEventListener('DOMContentLoaded', () => {
		    const contenedorCartas = document.querySelector('.cartas'); // Contenedor de cartas

		    if (contenedorCartas) {
			    contenedorCartas.addEventListener('click', event => {
			  // Detectar si se hizo clic en una carta
			       const carta = event.target.closest('.carta');
			       if (carta) {
				   // Solo permitir la interacción si estamos en el periodo de descarte
				        if (periodoDescarte) {
				          carta.classList.toggle('seleccionada');
				        } else {
				        console.log("No se puede seleccionar cartas fuera del periodo de descarte.");
				        }
			        }
			    });
		    } else {
			console.error('El contenedor de cartas no existe.');
		    }
		});

		// Seleccionamos todas las cartas
		document.querySelectorAll('.carta').forEach(carta => {
		  carta.addEventListener('click', () => {
			// Alternamos la clase 'seleccionada' al hacer clic
			carta.classList.toggle('seleccionada');
		  });
		});
		
		//======================================================
		// TRATAMIENTO DESCARTES al pulsar el botón "Descartar"
		//======================================================
		
		document.getElementById('descartar').addEventListener('click', () => {
		    const cartasSeleccionadas = obtenerCartasSeleccionadas(); // Cartas a descartar
		    const cartasOriginales = obtenerCartasOriginales(); // Cartas originales
		    console.log("Cartas descartadas:", cartasSeleccionadas, " cartas originales:", cartasOriginales);

		  // Lógica para enviar al servidor o procesar los descartes
		    //alert(`Cartas descartadas: ${cartasSeleccionadas.join(', ')}`);
			// Aquí se debería preguntar si el jugador tiene el turno de pedir cartas.
			// de hecho, el boton descartar solo se debería mostrar al jugador que le toque.
			
			if (cartasSeleccionadas.length === 0) {
				alert("Debes seleccionar al menos una carta para descartar.");
				return;
			}
		    //=================================================================
			// Comparar las cartas originales con las seleccionadas para encontrar las que se quedan
			const cartasRestantes = cartasOriginales.filter(carta => !cartasSeleccionadas.includes(carta));
		    console.log("Jugador que va a pedir cartas: ", "{{ usuario }}", " Cartas restantes: ", cartasRestantes);
			
			//alert("Va a hacer el emit de pedir_cartas");
			socket.emit('pedir_cartas', {
				mesa_id: "{{ mesa.nombre }}", 
				jugador: "{{ usuario }}", 
				num_cartas: cartasSeleccionadas.length,
				cartasRestantes: cartasRestantes,
				cartasSeleccionadas: cartasSeleccionadas
			})
			
			// Limpia las selecciones
			//document.querySelectorAll('.carta.seleccionada').forEach(carta => carta.classList.remove('seleccionada'));
			// Elimina las cartas seleccionadas visualmente
			cartasSeleccionadas.forEach(carta => {
				const cartaElement = document.getElementById(carta);
				if (cartaElement) cartaElement.remove();
			});
			
		  // Tenemos que recuperar las cartas que cada jugador se ha quedado y las que se descarta o si no que
		  // lógica las gestione el servidor y reparta cuatro nuevas cartas con las que se quedo y las nuevas.
		  // Hay que realizar un emit desde aquí cada cliente y el servidor repartir por turno.n
			
			
		  // alert("Se oculta el botón de Descartar, se vuelven a activar Corto y Mus solo al jugador turno");
		  // Finalizar el periodo de descarte
		    periodoDescarte = false;
			ocultarBotonDescartar();
			ocultarBotones();
			//limpiarHablado();
			const turnoNotificacion = document.getElementById("turnoNotificacion");
			turnoNotificacion.textContent = `Se inicia nueva ronda`;
			turnoNotificacion.classList.remove("oculto");
		  // Opcional: Desactivar las cartas después del descarte
		    document.querySelectorAll('.carta.seleccionada').forEach(carta => {
			  carta.classList.remove('seleccionada');


			// Marcar cartas como seleccionadas al hacer clic
			document.querySelectorAll('.carta').forEach(carta => {
				carta.addEventListener('click', function () {
					this.classList.toggle('seleccionada');
				});
			});

		});
		});

		socket.on('descartes_actualizados', (data) => {
			console.log("Descartes actualizados:", data);
        // este es el emit de py emit('descartes_actualizados', {'mesa_id': mesa_id, 'descartes': mesa['descartes']}, room=mesa_id)

			// Opcional: Actualizar el estado de descartes en la interfaz si es necesario
		});

		// Escuchar la respuesta del servidor para recibir nuevas cartas
		socket.on('cartas_pedidas', function (data) {
			const { jugador, turno_actual, contDescartados, nuevas_cartas, bot, owner, num_cartas } = data;
			console.log("cartas_pedidas data: ", data);
			const mesaId = "{{ mesa.nombre }}";
			const jugadorCliente = "{{ usuario }}";			
			// Actualiza las cartas del jugador en la interfaz
			//alert("usuario cliente: " + "{{ usuario }}" + " usuario py: " + jugador);
			if (jugador === jugadorCliente) {
				//alert("Jugador cliente: " + jugadorCliente + " nuevas cartas: " + nuevas_cartas);
				const cartasContainer = document.querySelector('.cartas');
				cartasContainer.innerHTML = ''; // Limpia las cartas actuales
				nuevas_cartas.forEach(carta => {
					const cartaElement = document.createElement('div');
					cartaElement.classList.add('carta');
					cartaElement.style.backgroundImage = `url('../static/img/cartas/${carta}.png')`;
					cartasContainer.appendChild(cartaElement);
				});
			}			
					
			if (jugador !== jugadorCliente ) {
				const turnoJugadorIdx = reorganizedJugadores.findIndex(jugador1 => jugador1 === jugador);	
				console.log("Cartas pedidas va a  mostrar descarte, jugador: ", jugador, " cartas: ", num_cartas);	
				mostrarDescarte(turnoJugadorIdx, num_cartas, 2000);
			}
			console.log("Cartas pedidas, jugador siguiente: ", turno_actual, " es bot: ", bot);
			
			//En el caso de que sea un bot, se descarta desde el servidor
			if (contDescartados < 4) {
				if ((bot === true) && (owner === jugadorCliente)) {
					console.log ("BOT cartas_pedidas. Va a llamar a BOT_tratar_descartar con jugador: ", turno_actual);
					socket.emit('BOT_tratar_descartar', { mesa_id: mesaId, jugadorTurno: turno_actual });
				} else {
					iniciarPeriodoDescarte(turno_actual);
				}
			}
			
			console.log("Contador de descartados === ", contDescartados);
			if (contDescartados === 4) {
				periodoDescarte = false;
				ocultarBotonDescartar();
				//limpiarHablado();
				if ((bot === true) && (owner === jugadorCliente)) {
					console.log ("BOT cartas_pedidas. Contador = 4. Va a llamar a BOT_tratar_mus_corto con jugador: " + turno_actual);
					socket.emit('BOT_tratar_mus_corto', { mesa_id: mesaId, jugadorTurno: turno_actual });
				} else {
					mostrarBotones(turno_actual);
				}
			}
		});
			
		function obtenerCartasSeleccionadas() {
		  const seleccionadas = [];
		  document.querySelectorAll('.carta.seleccionada').forEach(carta => {
			// Extraemos la URL del fondo
			const backgroundImage = carta.style.backgroundImage;

			// Extraemos solo el nombre del archivo
			const nombreCarta = backgroundImage
			  .replace(/url\(["']?/, '') // Elimina 'url("'
			  .replace(/["']?\)/, '') // Elimina '")'
			  .split('/').pop() // Obtiene solo el último segmento (el nombre del archivo)
			  .replace('.png', ''); // Elimina la extensión .png

			seleccionadas.push(nombreCarta); // Añade solo el nombre de la carta
		  });
		  return seleccionadas;
		}
		
		function obtenerCartasOriginales() {
		  const originales = [];
			document.querySelectorAll('.jugador-1 .cartas .carta').forEach(carta => {
			// Extraemos la URL del fondo
			const backgroundImage = carta.style.backgroundImage;
			// Extraemos solo el nombre del archivo
			const nombreCarta = backgroundImage
			  .replace(/url\(["']?/, '') // Elimina 'url("'
			  .replace(/["']?\)/, '') // Elimina '")'
			  .split('/').pop() // Obtiene solo el último segmento (el nombre del archivo)
			  .replace('.png', ''); // Elimina la extensión .png

			originales.push(nombreCarta); // Añade solo el nombre de la carta
		  });
		  return originales;
		}

		// Iniciar el periodo de descarte
		function iniciarPeriodoDescarte(jugadorDescarte) {
		  periodoDescarte = true;
		  mostrarBotonDescartar(jugadorDescarte);
		  console.log("Periodo de descarte activado");
		}
	
		// Mostrar el botón "Descartar"
		function mostrarBotonDescartar(jugadorDescarte) {
			const username = "{{ usuario }}";
			console.log("MostrarBotonDescartar. Usuario siguiente: ", jugadorDescarte);
			const botonDescartar = document.getElementById('descartar');
			//botonDescartar.textContent = `Turno descarte: ${jugadorDescarte}`;
			ocultarBotones();
			botonDescartar.innerHTML = `Turno de descarte:<br><strong>${jugadorDescarte}</strong>`;
			botonDescartar.style.display = 'inline-block'; // Cambia el estilo a visible
		    console.log("Botón Descartar: ", `Turno descarte: ${jugadorDescarte}`);
			//limpiarHablado();
			// Activar el botón solo para el usuario correspondiente
			if (username === jugadorDescarte) {
				botonDescartar.classList.add('activo'); // Habilitar el botón
			} else {
				botonDescartar.classList.remove('activo'); // Deshabilitar el botón
			}
		}

		// Ocultar el botón "Descartar"
		function ocultarBotonDescartar() {
			const botonDescartar = document.getElementById('descartar');
			botonDescartar.style.display = 'none'; // Oculta el botón
		}
	  // Función para mostrar los botones de MUS y Corto después de repartir
	    function mostrarBotones(jugadorActual) {
			const username = "{{ usuario }}";
			const botonesJuego = document.getElementById('botones-juego');
			//const turnoLabel = document.getElementById("turnoJugador");
			const btnCorto = document.getElementById('btn-corto');
			const btnMus = document.getElementById('btn-mus');
			console.log("Va a MOSTRAR los botones de Corto y Mus. Usuario:", username, " jugadorActual: ", jugadorActual);
			//turnoLabel.classList.remove("oculto"); 
			botonesJuego.style.display = 'flex'; // Mostrar los botones de MUS y Corto
			//turnoLabel.textContent = `Turno ${jugadorActual}`; // Mostrar etiqueta con el jugador en turno
			const indiceJugador = jugadores.indexOf(jugadorActual) + 1;
			mostrarTurno(jugadorActual, indiceJugador);
			// Activar los botones de Mus y Corto solo para el usuario del turno
			btnCorto.disabled = true;
			btnMus.disabled = true;
			if (username === jugadorActual) {
                btnCorto.disabled = false;
                btnMus.disabled = false;
            }
	    }
		
		//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		//	Función para ocultar los botones de MUS y Corto después de repartir		
		//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		
	    function ocultarBotones() {
			//const turnoLabel = document.getElementById("turnoJugador");
			//turnoLabel.classList.add("oculto");
			console.log("Va a OCULTAR los botones de Corto y Mus.");
			const botonesJuego = document.getElementById('botones-juego');
			botonesJuego.style.display = 'none'; // Ocultar los botones de MUS y Corto
	    }
				
		function mostrarMesaBotones(apuesta) {		
			const mesaBotones = document.querySelector('.mesa-botones');
			mesaBotones.style.display = 'flex';
			mesaBotones.classList.add('fade-in');
			const botines = document.querySelectorAll('.botines');
			botines.forEach(botin => {
				botin.classList.remove('bloqueado'); // Desbloquea
			});	
			console.log("mostrarMesaBotones. Apuesta: ", apuesta);
			const botver = document.getElementById('ver');
			if (apuesta == 0) {
				botver.classList.add('bloqueado');				
			} else {
				botver.classList.remove('bloqueado');
			}
			const botord = document.getElementById('ordago');
			const botenv = document.getElementById('envidar');
			const botdec = document.getElementById('decrementar-envido');
			const botinc = document.getElementById('incrementar-envido');
			if (apuesta >= 40) {
				botord.classList.add('bloqueado');				
				botenv.classList.add('bloqueado');		
				botdec.classList.add('bloqueado');	
				botinc.classList.add('bloqueado');	
			} else {  
				console.log("mostrarMesaBotones. Debería entrar por aqui");
				botord.classList.remove('bloqueado');
				botenv.classList.remove('bloqueado');
				botdec.classList.remove('bloqueado');
				botinc.classList.remove('bloqueado');
			}
		}
		
		function bloquearMesaBotones() {
			const mesaBotones = document.querySelector('.mesa-botones');
			mesaBotones.style.display = 'flex';
			mesaBotones.classList.add('fade-in');
			const botines = document.querySelectorAll('.botines');
			botines.forEach(botin => {
				botin.classList.add('bloqueado'); // Bloquea
			});			
		}
		function ocultarMesaBotones() {
		    const mesaBotones = document.querySelector('.mesa-botones');
		    mesaBotones.style.display = 'none';
		}

	// CODIGO PARA LA GESTION DE LOS TURNOS Y ACTIVACIÓN Y DESACTIVACION DE BOTONES
	
    // Mostrar notificación de turno con intervalo de tres segundos
    function mostrarTurno(jugador, idxJugador) {
		const turnoNotificacion = document.getElementById("turnoNotificacion");
 		turnoNotificacion.textContent = `Es el turno de ${jugador}`;
		turnoNotificacion.classList.remove("oculto");
		//const timer = `timer-${idxJugador}`;
		//const contfin = `countdown-${idxJugador}`;
		//alert("Timer: " + timer + " countdown: " + contfin);
		//startTimer(timer, contfin, 10);

      // Ocultar la notificación después de 3 segundos
    //  setTimeout(() => {
    //    turnoNotificacion.classList.add("oculto");
    //  }, 3000);
    }

	// Escuchar mensajeserrores del servidor
    function mostrarAccion(mensaje) {
 		turnoNotificacion.textContent = `${mensaje}`;
		turnoNotificacion.classList.remove("oculto");
	}
	
	// Escuchar mensajeserrores del servidor
	socket.on('mostrarMensaje', function(data) {
		const usuario = "{{ usuario }}";  
		const jugadorDescarta = data.jugador;
		const num_cartas = data.num_cartas;
		const cartulaje = data.cartulaje;
		const turnoJugadorIdx = reorganizedJugadores.findIndex(jugador => jugador === jugadorDescarta);	
		const turnoNotificacion = document.getElementById("turnoNotificacion");
 		turnoNotificacion.textContent = `${data.msg}`;
		turnoNotificacion.classList.remove("oculto");
		const mePido = "Quiero " + num_cartas + cartulaje;
		//mostrarBocadillo2(turnoJugadorIdx, mePido);
		if (cartulaje === "Mus") {
			mostrarHablado(turnoJugadorIdx, cartulaje);
		} else {
			mostrarHablado(turnoJugadorIdx, mePido);
		}
		//alert("mostrarMensaje. Jugador: " + jugadorDescarta + " dice: " + mePido);
		console.log("mostrarMensaje. Jugador: ", jugadorDescarta, " dice: ", mePido);
		//if (jugadorDescarta !== usuario ) {
		//	mostrarDescarte(turnoJugadorIdx, num_cartas, 5000);
		//}
	});

	function mostrarDescarte(indice, numCartas, retrasoInicio) {
	  setTimeout(() => {
		const posiciones = ["jugador-1", "jugador-2", "jugador-3", "jugador-4"];
		const position = posiciones[indice];

		console.log(
		  "Mostrar cartas con descarte y regeneración. Posición: ",
		  position,
		  " Índice: ", 
		  indice, 
		  " Número de cartas a solicitar: ", 
		  numCartas
		);

		// Buscar el contenedor del jugador por clase
		const jugadorElement = document.querySelector(`.${position}`);
		if (!jugadorElement) {
		  console.error(`No se encontró el contenedor para el jugador en la posición ${position}`);
		  return;
		}

		const contenedorCartas = jugadorElement.querySelector(".cartas");
		if (!contenedorCartas) {
		  console.error(`No se encontró el contenedor de cartas dentro del jugador ${position}`);
		  return;
		}

		// Crear las 4 cartas inicialmente
		const totalCartas = 4;
		contenedorCartas.innerHTML = ""; // Limpiar cartas actuales
		for (let i = 0; i < totalCartas; i++) {
		  const carta = document.createElement("div");
		  carta.classList.add("carta", "carta-oculta");
		  contenedorCartas.appendChild(carta);
		}

		// Seleccionar las cartas que se van a descartar (de derecha a izquierda)
		const cartas = Array.from(contenedorCartas.children);
		for (let i = 0; i < numCartas; i++) {
		  const carta = cartas[totalCartas - 1 - i]; // De derecha a izquierda

		  // Efecto de descarte (desaparecer con animación)
		  setTimeout(() => {
			carta.style.transition = "transform 0.5s ease, opacity 0.5s ease";
			carta.style.transform = "translateY(50px) rotate(-20deg)";
			carta.style.opacity = "0";
		  }, i * 200);
		}

		// Regenerar cartas solicitadas (de izquierda a derecha)
		setTimeout(() => {
		  for (let i = 0; i < numCartas; i++) {
			const carta = cartas[totalCartas - numCartas + i];

			setTimeout(() => {
			  carta.style.transition = "transform 0.5s ease, opacity 0.5s ease";
			  carta.style.transform = "translateY(0) rotate(0)";
			  carta.style.opacity = "1";
			  carta.classList.add("carta-oculta");
			}, i * 200);
		  }
		}, numCartas * 200 + 500);
		
	  }, retrasoInicio);
	}



    // Recibir actualizaciones para comenzar la ronda desde el servidor
    socket.on('comenzar_ronda', (data) => {
		indiceMano = data.turno_actual;
		jugadorTurno = data.jugador_turno;	
		jugadorCorto = data.jugadorCorto;
		const mesaId = "{{ mesa.nombre }}";
		const jugadorCliente = "{{ usuario }}";		
		const bot = data.bot;
		const owner = data.owner;
		
		mostrarTurno(jugadorTurno, indiceMano+1);
		console.log('COMENZAR RONDA: jugadorTurno desde servidor:', jugadorTurno, " jugador cliente: ", "{{ usuario }}");
		ocultarBotones();
		const manoJugadorIdx = reorganizedJugadores.findIndex(jugador => jugador === jugadorTurno);	
		console.log("Comenzar ronda. Jugador mano es: ", jugadorTurno, " indice reorganiced es: ", manoJugadorIdx);
		resaltarManoDescarte(manoJugadorIdx);
		const manoJugadorIdx2 = reorganizedJugadores.findIndex(jugador => jugador === jugadorCorto);	
		//mostrarBocadillo2(manoJugadorIdx2, "Corto");	
		limpiarHablado();
		mostrarHablado(manoJugadorIdx2, "Corto");
		const textoLance = document.getElementById('texto-lance');
		textoLance.textContent = "Grande";

		console.log ("Comenzar_ronda. Bot: ", bot, " jugador: " + jugadorTurno);
		if ((bot === true) && (owner === jugadorCliente)) {
			console.log ("BOT comenzar_ronda. Va a llamar a BOT_tratar_juego 2 con jugador: " + jugadorTurno);
			socket.emit('BOT_tratar_juego', { donde: "JS BOT_tratar_juego 2 ", mesa_id: mesaId, jugadorTurno: jugadorTurno });
		}
	
		const esMiTurno = jugadorTurno === "{{ usuario }}";
		if (esMiTurno) {
			mostrarMesaBotones(0);
			console.log("Es tu turno. Puedes jugar.");
		} else {
			// Desactivar/bloquear los botones del centro 
			bloquearMesaBotones();
			//alert("Espera tu turno.");
		}
    });	

		//==================================================
		// TRATAMIENTO DE LOS BOTONES DE CADA LANCE
		//==================================================
		// Valor inicial del envido
		let valorEnvido = 2;

		// Referencias a los elementos
		const spanEnvido = document.getElementById('valor-envido');
		const botonIncrementar = document.getElementById('incrementar-envido');
		const botonDecrementar = document.getElementById('decrementar-envido');
		const botonEnvidar = document.getElementById('envidar');
		const jugadores = mesa.jugadores;
		const jugador = mesa.jugadores[mesa.mano];   //"{{ usuario  }}";
		
		// Incrementar el valor del envido
		botonIncrementar.addEventListener('click', () => {
		  valorEnvido++;
		  spanEnvido.textContent = valorEnvido;
		});

		// Decrementar el valor del envido
		botonDecrementar.addEventListener('click', () => {
		  if (valorEnvido > 2) {
			valorEnvido--;
			spanEnvido.textContent = valorEnvido;
		  }
		});

		// Acción al hacer clic en el botón de "Envidar"
		botonEnvidar.addEventListener('click', () => {	
			const mesaId = "{{ mesa.nombre }}";		
			const jugadorC = "{{ usuario }}";
			console.log("Clic en el botón de Envidar", `${jugadorC} envida ${valorEnvido}`);
			enviarAccion(jugadorC, "Envido", valorEnvido);
			valorEnvido = 2;
		});

		// Botón de Órdago
		document.getElementById('ordago').addEventListener('click', () => {
			//alert('¡Órdago lanzado!');
			const jugadorC = "{{ usuario }}";
			console.log(`${jugadorC} lanza un órdago.`);
			enviarAccion(jugadorC, "Órdago");
		});
		// Botón de Ver
		document.getElementById('ver').addEventListener('click', () => {
		    //alert('Has visto el envido.');
			const jugadorC = "{{ usuario }}";
			console.log(`${jugadorC} ve el envite.`);
			enviarAccion(jugadorC, "Veo");
		});

		// Botón de Paso
		document.getElementById('paso').addEventListener('click', () => {
			//alert('Has pasado.');
			const jugadorC = "{{ usuario }}";
			console.log(`${jugadorC} ha pasado.`);
			enviarAccion(jugadorC, "Paso");
		});

		function enviarAccion(jugadorC, accion, valorEnvido = 0) {
			const mensaje = {
				mesa_id: mesaId,
				jugador: jugadorC,
				accion: accion,
				envido: valorEnvido  // Valor del envido si aplica
			};
			socket.emit('accion_jugador', mensaje);
		}
			
	//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	// RECIBE CADA ITERACION DEL JUEGO Y ACTUALIZA LA INTERFAZ DEL CLIENTE %
	//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	
	socket.on('estado_actualizado', (mesa) => {
		//console.log("Estado actualizado Mesa: ", mesa);
		const jugadorActual = "{{ usuario }}";
		const jugadorAnterior = mesa.jugadorAnterior;
		const turnoActual = mesa.turno_actual;
		const finRonda = mesa.fin_ronda;
		const bot = mesa.bot_activo[turnoActual];
		const owner = mesa.owner;
		const mesaId = "{{ mesa.nombre }}";
		const turnoJugador = mesa.jugadores[turnoActual];
		const lanceActual = mesa.lance_actual;
		const accion = mesa.accion;
		// Obtener el índice del lance para conocer su apuesta
		const apuestaActual = mesa.apuesta_actual;
		const indiceApuesta = mesa.lances.indexOf(lanceActual);
		let apuesta = mesa.apuesta[indiceApuesta];
		let apuestaLance = apuesta;
		let hablar = accion; 
		let hablar2 = "envida";
		console.log("Estado actualizado turno actual:", turnoActual, " turnoJugador: ", turnoJugador, " jugAnterior: " + jugadorAnterior, " jugadorCliente: ", jugadorActual, " accion: ", accion);		
		// Inicializamos con 2 el valor de envido.	
		let valorEnvido = 2;
		const spanEnvido = document.getElementById('valor-envido');
		spanEnvido.textContent = 2;
		
		// El jugador anterior habla su lance	
		if (accion === "Paso") {
			apuesta = 0;
		}
		
		if ((apuesta === 0) || (apuesta === 2) || (apuestaActual === apuesta)) { 
			if (apuesta >= 3) {
			hablar = accion + " " + apuestaActual; 
			hablar2 = "envida" + " " + apuestaActual;
			} else {
				hablar = accion;
			}
		} else { 
		//	hablar = accion + " " + apuestaActual + " y van " + apuesta; 
			hablar = apuestaActual + " más y van " + apuesta; 
			hablar2 = "envida " + apuestaActual + " más y van " + apuesta; 
		}  
		if (apuesta >= 40) {
			mensaje = jugadorAnterior + " lanza un ÓRDAGO";
			hablar = "¡¡¡ÓRDAGO!!!";
		} else {
			mensaje = jugadorAnterior + " " + hablar2;
		}
		if (accion === "Veo") {
			hablar2 = " ve la apuesta";
			hablar = accion;
		}
		if (accion === "Paso") {
			hablar2 = " pasa";
			hablar = accion;			
		}		
		mostrarAccion(mensaje);
 		
		//console.log("Accion: ", accion, "Lance: ", lanceActual, " habla ", jugadorAnterior, " y dice: ", hablar);
		//console.log('Estado actualizado. manoJugadorIdx: ', manoJugadorIdx, " reorganizedJugadores: ", reorganizedJugadores);

		const manoJugadorIdx = reorganizedJugadores.findIndex(jugador => jugador === jugadorAnterior);	
		//mostrarBocadillo2(manoJugadorIdx, hablar);	
		mostrarHablado(manoJugadorIdx, hablar);
		
		// Actualizar marcador
		document.getElementById('puntos-pareja1').textContent = mesa.puntos[0];
		document.getElementById('puntos-pareja2').textContent = mesa.puntos[1];

		// Actualizar los juegos 
		document.getElementById('juegos-pareja1').textContent = mesa.juegos[0];
		document.getElementById('juegos-pareja2').textContent = mesa.juegos[1];

		// Actualizar turno
		//mostrarTurno(turnoJugador);

		console.log('Estado actualizado. es el turno de: ', turnoJugador, " jugador cliente: ", jugadorActual, " jugador anterior: ", jugadorAnterior);

		// Actualizar lanceturno
		const textoLance = document.getElementById('texto-lance');
		textoLance.textContent = lanceActual;
		
		mostrarTurno(turnoJugador, turnoActual+1);
		
		let llamar_bot = true;
		if (mesa.lance_actual === 'Pares') {
			if ((mesa.total_con_pares < 2) || (mesa.total_con_pares === 2 &&  mesa.contrarias_pares === false)) {
				llamar_bot = false;
			}
		}
		if (mesa.lance_actual === 'Juego') {
			if ((mesa.total_con_juego < 2) || (mesa.total_con_juego === 2 && mesa.contrarias_juego === false)) {
				llamar_bot = false;
			}
		}
		console.log("BOT estado_actualizado. llamar_bot: ", llamar_bot, " pares: ", mesa.total_con_pares, " juego: ", mesa.total_con_juego, " conp: ", mesa.contrarias_pares, " conj: ", mesa.contrarias_juego); 
		// Si le toca al bot decide el servidor. Solo llama el owner de la mesa cuando coincide con el usuario cliente para que sea una vez.
		//alert ("Fin ronda en manejar accion: " + finRonda);
		console.log("BOT estado_actualizado. fin ronda: ", finRonda, " estado_partida: ", mesa.estado_partida, " lance: ", mesa.lance_actual);
		if (llamar_bot === true) {
			if ((bot === true) && (owner === jugadorActual) && (mesa.estado_partida === 'Jugar')) {
				//alert ("Vamos a llamar a py BOT_tratar_juego 3 con jugador: " + turnoJugador + " y mesa: " + mesaId);
				console.log ("BOT estado_actualizado. VVVa a llamar a BOT_tratar_juego 3 con jugador: " + turnoJugador);
	     			socket.emit('BOT_tratar_juego', { donde: "JS BOT_tratar_juego 3 ", mesa_id: mesaId, jugadorTurno: turnoJugador });
			}
		}
		
		if (mesa.estado_partida === 'Jugar') {
		  if (turnoJugador === jugadorActual) {
			mostrarMesaBotones(apuestaLance);
		  } else {
			bloquearMesaBotones();
		  }
		} else {
		  bloquearMesaBotones();
		}		
	});

	socket.on("pares_confirmados", async (data) => {
		const resultados = data.resultados_pares;
		const lance = data.lance;
		const total_pares = data.total_pares;
		const turno_actual = data.turno_actual;
		const contrarias = data.contrarias;
		const bot = data.bot;
		const owner = data.owner;
		const finRonda = data.fin_ronda;
		const estadoPartida = data.estado_partida;
		const mano = data.mano;
		const mesaId = "{{ mesa.nombre }}";
		console.log("Resultados de pares recibidos:", resultados, " lance: ", lance, " total_pares: ", total_pares, " turno_actual: ", turno_actual, " parejas contrarias: ", contrarias);
		const jugadorActual = "{{ usuario }}";
		const turnoJugador = jugadores[turno_actual];
		const turnoMano = jugadores[mano];
		
		// Actualizar el texto del lance
		const textoLance = document.getElementById('texto-lance');
		textoLance.textContent = "Pares";
		
		//console.log("Pares confirmados: Puntos: ", data.puntos);
		// Actualizar marcador
		//document.getElementById('puntos-pareja1').textContent = data.puntos[0];
		//document.getElementById('puntos-H').textContent = data.puntos[1];

		// Bloquear botones de la mesa mientras se realiza el cante
		// bloquearMesaBotones();

		// Función auxiliar para esperar y mostrar bocadillos

	//{'bot1': False, 'Gordiano1': False, 'bot2': True, 'bot3': False}  es el turno de : bot2  hay  1  jugadores con pares.  contrarias:  False		
		const mostrarConEspera = async (jugadorP, tienePares, manoJugadorIdx) => {
			return new Promise((resolve) => {
				setTimeout(() => {
					let mensaje;
					if (tienePares) {
						mensaje = `${jugadorP} tiene pares.`;
						mostrarHablado(manoJugadorIdx, "Tengo pares");
						//mostrarBocadillo2(manoJugadorIdx, "SI tengo pares");
					} else {
						mensaje = `${jugadorP} no tiene pares.`;
						mostrarHablado(manoJugadorIdx, "No tengo pares");
						//mostrarBocadillo2(manoJugadorIdx, "NO tengo pares");
					}
					console.log(mensaje); // Muestra el mensaje en la consola
					resolve(); // Indica que esta operación ha terminado
				}, 1000);
			});
		};

		const startIndex = reorganizedJugadores.indexOf(turnoMano);
		const n = reorganizedJugadores.length;

		if (startIndex === -1) {
		  console.error("El turnoMano no se encuentra en reorganizedJugadores.");
		} else {
		  for (let i = 0; i < n; i++) {
			// currentIndex avanza cíclicamente
			const currentIndex = (startIndex + i) % n;
			const jugadorP = reorganizedJugadores[currentIndex];
			const tienePares = resultados[jugadorP];
			console.log("Iterando con jugador:", jugadorP, " tienepares: ", tienePares, " currentIdenx: ", currentIndex);
			// Aquí, ojo si la lógica de mostrarHablado requiere que el índice sea "i" o "currentIndex"
			await mostrarConEspera(jugadorP, tienePares, currentIndex);
		  }
		}

		console.log("BOT pares_confirmados. fin ronda: ", finRonda, " estado_partida: ", estadoPartida);
		 if ((total_pares > 2) || (total_pares === 2 && contrarias)) {
			if (finRonda === false) {
				if ((bot === true) && (owner === jugadorActual) && estadoPartida === 'Jugar') {
				  console.log("BOT pares_confirmados. Va a llamar a BOT_tratar_juego 4 con jugador: " + turnoJugador);
				  socket.emit('BOT_tratar_juego', { donde: "JS BOT_tratar_juego 4", mesa_id: mesaId, jugadorTurno: turnoJugador });
				}
			}
		} 
		// En el caso de que al menos haya dos jugadores contrarios con pares, comienza el lance
		if ((total_pares > 2) || (total_pares === 2 && contrarias)) {
		  console.log("Hay partida de pares ");
		  mostrarTurno(turnoJugador, turno_actual+1);
		  // Si le toca al bot decide el servidor. Solo llama el owner de la mesa para que sea una vez.
		  // Mostrar/ocultar botones según el turno
		  if (turnoJugador === jugadorActual) {
			mostrarMesaBotones(0);
		  } else {
			bloquearMesaBotones();
		  }
		}
	});

	socket.on("juego_confirmado", async (resultados) => {
		const mesaId = "{{ mesa.nombre }}";
		const jugadorActual = "{{ usuario }}";
		const turnoJugador = resultados.turno_actual;
		const total_juego = resultados.total_juego;
		const turno_actual = jugadores.findIndex(jugador => jugador === turnoJugador);
		const contrarias = resultados.contrarias;
		const bot = resultados.bot;
		const owner = resultados.owner;
		const finRonda = resultados.fin_ronda;
		const estadoPartida = resultados.estado_partida;
		const mano = resultados.mano;		
		const turnoMano = jugadores[mano];
		console.log("Resultados de juego recibidos:", resultados, " turnoJugador: ", turnoJugador, " turno_actual: ", turno_actual, " contrarias: ", contrarias);

		// Actualizar el texto del lance en la interfaz
		const textoLance = document.getElementById('texto-lance');
		textoLance.textContent = "Juego";

		// Bloquear botones mientras se realiza el cante
		bloquearMesaBotones();
		
		// Función auxiliar para mostrar cada resultado con una espera
		const mostrarJuegoConEspera = async (infoJuego, manoJugadorIdx) => {
			return new Promise((resolve) => {
				setTimeout(() => {
					let mensaje;
					if (infoJuego.tiene_juego) {
						mensaje = `${infoJuego.jugador} tiene juego.`;
						mostrarHablado(manoJugadorIdx, "Tengo juego");						
						//mostrarBocadillo2(manoJugadorIdx, "SI tengo juego");
					} else {
						mensaje = `${infoJuego.jugador} no tiene juego.`;
						mostrarHablado(manoJugadorIdx, "No tengo juego");						
						//mostrarBocadillo2(manoJugadorIdx, "NO tengo juego");
					}
					console.log(mensaje); // Muestra el mensaje en la consola
					resolve(); // Indica que se completó este paso
				}, 1000);
			});
		};

		// Encontramos el índice donde se encuentra el jugador que es mano
		const startingIndex = resultados.resultado_juego.findIndex(
		  infoJuego => infoJuego.jugador === turnoMano
		);

		if (startingIndex === -1) {
		  console.error(`El jugador ${turnoMano} no se encontró en estado_juego.`);
		} else {
		  const totalJugadores = resultados.resultado_juego.length;
		  // Iteramos usando un índice que rota cíclicamente
		  for (let i = 0; i < totalJugadores; i++) {
			const currentIndex = (startingIndex + i) % totalJugadores;
			const infoJuego = resultados.resultado_juego[currentIndex];
			
			// Busca el índice del jugador en reorganizedJugadores
			const manoJugadorIdx = reorganizedJugadores.findIndex(jugador => jugador === infoJuego.jugador);
			if (manoJugadorIdx === -1) {
			  console.error(`Jugador ${infoJuego.jugador} no encontrado en reorganizedJugadores.`);
			  continue; // Salta al siguiente jugador si no encuentra el índice
			}
			
			console.log("juego_confirmado. Jugador:", infoJuego.jugador, "manoJugadorIdx:", manoJugadorIdx);
			// Espera a que se muestre el resultado de este jugador
			await mostrarJuegoConEspera(infoJuego, manoJugadorIdx);
		  }
		}

		console.log("BOT juego_confirmado. fin roda: ", finRonda, " con juego: ", total_juego, " parejas contrarias: ", contrarias);
		if ((total_juego > 2) || (total_juego === 2 && contrarias)) {
			if (finRonda === false) {
				// Si le toca al bot decide el servidor. Solo llama el owner de la mesa para que sea una vez.
				if ((bot === true) && (owner === jugadorActual) && estadoPartida === 'Jugar') {
				  console.log("BOT juego_confirmado. Va a llamar a BOT_tratar_juego 5 con jugador: " + turnoJugador);
				  socket.emit('BOT_tratar_juego', { donde: "JS BOT_tratar_juego 5", mesa_id: mesaId, jugadorTurno: turnoJugador });
				}
			}
		} 
		
		// En el caso de que al menos haya dos jugadores contrarios con juego, comienza el lance
		if ((total_juego > 2) || (total_juego === 2 && contrarias)) {
		  console.log("Hay partida de juego ");
		  mostrarTurno(turnoJugador, turno_actual+1);
		  // Mostrar/ocultar botones según el turno
		  if (turnoJugador === jugadorActual) {
			mostrarMesaBotones(0);
		  } else {
			bloquearMesaBotones();
		  }
		}
	});

	socket.on("actualizar_interfaz_ronda", (data) => {
		const jugadorCliente = "{{ usuario }}";
		const mesa_id = "{{ mesa.nombre }}";
		const turnoActual = data.turno_actual;
		const jugadorActual = jugadores[turnoActual];
		const jugadorAnterior = data.jugadorAnterior;
		const manos = data.manos;
		const apuesta = data.apuesta;
		const juegos_vaca = data.juegos_vaca;
		const puntos_juego = data.puntos_juego;
		const finRonda = data.finRonda;
		console.log("actualizar_interfaz_ronda. Data: ", data);
		//alert("Inicia actualizar_interfaz_ronda ");	
		ocultarMesaBotones();
		limpiarHablado();
		cartas_boca_arriba(manos);
		console.log("Se ponen las cartas bocaarriba");
		// Crear las parejas truncadas
		const pareja1 = `${truncarNombre(jugadores[0])} - ${truncarNombre(jugadores[2])}`;
		const pareja2 = `${truncarNombre(jugadores[1])} - ${truncarNombre(jugadores[3])}`;
		// Crear las parejas 
		const pareja1L = `${jugadores[0]} - ${jugadores[2]}`;
		const pareja2L = `${jugadores[1]} - ${jugadores[3]}`;		
		document.getElementById('nombre-pareja1').textContent = pareja1;
		document.getElementById('nombre-pareja2').textContent = pareja2;

		// Actualizar marcador
		document.getElementById('puntos-pareja1').textContent = data.puntos[0];
		document.getElementById('puntos-pareja2').textContent = data.puntos[1];

		// Actualizar los juegos 
		document.getElementById('juegos-pareja1').textContent = data.juegos[0];
		document.getElementById('juegos-pareja2').textContent = data.juegos[1];

		if ((data.puntos[0] >= puntos_juego) || (data.puntos[1] >= puntos_juego)) {
			// Actualizar el marcador de juegos:
			data.puntos.forEach((puntos, equipo) => {
				if (puntos >= puntos_juego) {

					if (apuesta >= puntos_juego) { 
						accion = "ÓRDAGO";
					} else {
						accion = "juego";
					}
					// Establecer el mensaje
					//const mensajeCentral = `¡La pareja<br>${pareja1L}<br>gana el ${accion}!`;	
					//if (equipo === 1) {
					//	const mensajeCentral = `¡La pareja<br>${pareja2L}<br>gana el ${accion}!`;				
					//}
					const mensajeCentral = `¡La pareja ${equipo + 1} gana el ${accion}!`;
					// Sumar 1 al juego correspondiente
					data.juegos[equipo] += 1;
					data.puntos[0] = 0;
					data.puntos[1] = 0;		
					mesa.puntos[0] = 0;
					mesa.puntos[1] = 0;					
					console.log("BOCADILLO JUEGO GANA el juego equipo: ", equipo, " juegos parametro: ", juegos_vaca, " juegos ganados: ", data.juegos[equipo]);
					// Actualizar los juegos en el marcador
					document.getElementById('puntos-pareja1').textContent = data.puntos[0];
					document.getElementById('puntos-pareja2').textContent = data.puntos[1];				
					document.getElementById('juegos-pareja1').textContent = data.juegos[0];
					document.getElementById('juegos-pareja2').textContent = data.juegos[1];

					// Mensaje en consola para depuración
					console.log("Mensaje central: ", mensajeCentral, " data.puntos: ", data.puntos, " apuesta: ", apuesta);
					console.log(`¡La pareja ${equipo + 1} ha superado los ${puntos_juego} puntos! Juegos actualizados: ${data.juegos[equipo]}`);
					if (data.juegos[equipo] === juegos_vaca) {  
						mostrarPopup(mesa_id, mensajeCentral);
					} else {
						//alert("Entra a mostrarBocadilloCentral");
						mostrarBocadilloCentral(mensajeCentral, 0); // Mostrar por 4 segundos
					}
				}
			});	
		} else {
			// Mostrar el bocadillo de puntos después de 4 segundos

			const bocadilloPuntos = document.getElementById('bocadillo-puntos');

			// Actualizar los puntos de la tabla
			document.getElementById('puntos-grande-pareja1').textContent = data.grande[0];
			document.getElementById('puntos-chica-pareja1').textContent = data.chica[0];
			document.getElementById('puntos-pares-pareja1').textContent = data.pares[0];
			document.getElementById('puntos-grande-pareja2').textContent = data.grande[1];
			document.getElementById('puntos-chica-pareja2').textContent = data.chica[1];
			document.getElementById('puntos-pares-pareja2').textContent = data.pares[1];
		    //alert("Hasta aqui bien 2");
			// Actualizar con 'Juego' si alguno de los valores data.juego[0] o data.juego[1] es mayor a 0.
			const lanceFinal = data.juego[0] > 0 || data.juego[1] > 0 ? 'Juego' : 'Punto';
			if (lanceFinal === 'Juego') {
				document.querySelector('#bocadillo-puntos thead tr th:last-child').textContent = "Juego";
				document.getElementById('puntos-juepu-pareja1').textContent = data.juego[0];
				document.getElementById('puntos-juepu-pareja2').textContent = data.juego[1];
			} else {
				document.querySelector('#bocadillo-puntos thead tr th:last-child').textContent = "Punto";
				document.getElementById('puntos-juepu-pareja1').textContent = data.punto[0];
				document.getElementById('puntos-juepu-pareja2').textContent = data.punto[1];
			}	
			esperarBocadilloPuntos(bocadilloPuntos);
		}
		console.log("Ha enseñado el bocadillo puntos");
		
		// Actualizar turno
		//alert("Hasta aqui bien 3");
		mostrarTurno(jugadorActual, turnoActual+1);
		console.log('Interfaz ronda. es el turno de: ', jugadorActual, ' jugador actual: ', jugadorActual, ' jugador cliente: ', jugadorCliente);
		ocultarMesaBotones();
		const btnRepartir = document.getElementById("btn-repartir");
		btnRepartir.classList.remove("oculto");
		console.log("Muestra botón repartir");			
		// Habla el jugador mano nueva ronda
		//alert("Hasta aqui bien 4");
		//console.log("Comenzar ronda. Jugador mano es: ", jugadorActual, " indice reorganiced es: ", manoJugadorIdx);
		//mostrarBocadillo2(manoJugadorIdx, "Empezamos la ronda. Soy mano.");	
		//alert("Hasta aqui bien 5");
		//limpiarHablado();		
	
		// Reparte el jugador anterior
		const manoJugadorIdx = reorganizedJugadores.findIndex(jugador => jugador === jugadorActual);	
		const manoJugadorIdx2 = reorganizedJugadores.findIndex(jugador => jugador === jugadorAnterior);	
		resaltarManoDescarte(manoJugadorIdx);
		mostrarBocadillo2(manoJugadorIdx, "Es mano ");		
		mostrarBocadillo2(manoJugadorIdx2, "Reparto");	
		//alert("Termina actualizar_interfaz_ronda");		
		// Ocultar el botón de repartir 
		//const btnRepartir = document.getElementById("btn-repartir");
		//btnRepartir.classList.add("oculto");
		console.log("Termina actualizar_interfaz_ronda");	
	}); 

	function cartas_boca_arriba(manosMesa) {
		
		const manos = manosMesa;
		console.log("Cartas Boca Arriba. Manos: ", manos);
		const jugadores = mesa.jugadores;

		Object.keys(manos).forEach((jugador) => {
			const cartas = manos[jugador];

			// Encuentra el div correspondiente al jugador actual
			const jugadorDiv = Array.from(document.querySelectorAll('.jugador')).find(div => {
				const alias = div.querySelector('.alias').textContent;
				return alias === jugador;
			});

			if (jugadorDiv) {
				// Limpiar las cartas actuales
				const cartasDiv = jugadorDiv.querySelector('.cartas');
				cartasDiv.innerHTML = '';

				// Asignar las cartas
				cartas.forEach(carta => {
					const cartaElement = document.createElement('div');
					cartaElement.classList.add('carta');

					// Crear la ruta de la imagen
					const rutaImagen = `/static/img/cartas/${carta}.png`;
					cartaElement.style.backgroundImage = `url(${rutaImagen})`;
					cartaElement.style.backgroundSize = 'cover';
					cartaElement.style.backgroundPosition = 'center';

					cartasDiv.appendChild(cartaElement);
				});
			}
		});
	}

	async function mostrarBocadilloCentral(mensaje, espera) {
		//setTimeout(() => {
			// Seleccionar el bocadillo
			const bocadilloCentral = document.getElementById('mensaje-central');
			//bocadillo.style.display = 'block';
			//bocadillo.style.zIndex = '9999';
			console.log("mostrarBocadilloCentral: ", mensaje, " Espera: ", espera);
			//bocadillo.textContent = mensaje;
			 bocadilloCentral.innerHTML = mensaje;
			// Mostrar el bocadillo
			bocadilloCentral.classList.remove('mensaje-oculto');
			bocadilloCentral.classList.add('mensaje-visible');
			// Ocultarlo después de 8 segundos
			await esperar(8000);
			//setTimeout(() => {
				bocadilloCentral.classList.remove('mensaje-visible');
				bocadilloCentral.classList.add('mensaje-oculto');
		//	}, 3000);
		//}, espera);
	}
	async function esperarBocadilloPuntos(bocadilloPuntos) {
		// Muestra el bocadillo
		bocadilloPuntos.classList.remove('oculto');
		await esperar(8000);
		// Después ocultamos el bocadillo de puntos
		bocadilloPuntos.classList.add('oculto');
	} 
	function esperar(ms) {
		return new Promise(resolve => setTimeout(resolve, ms));
	}
	
    // Bloquear botones desde servidor
	socket.on('bloquear_mesa_botones', (lance) => {
		console.log("Entra en bloquear_mesa_botones: ", lance);
		//limpiarHablado();
		bloquearMesaBotones();
	});	


//*******************************************************************
// Mostrar la ventana emergente del final de la partida
//*******************************************************************

	function mostrarPopup(mesa_id, mensaje) {
		const popup = document.getElementById('popup');
		const popupMessage = document.getElementById('popup-message');
		popupMessage.innerHTML = mensaje; // Cambia el mensaje dinámicamente
		popup.classList.remove('hidden');
	}

	// Manejar botones
	document.getElementById('btn-exit').addEventListener('click', () => {

		const jugadorCliente = "{{ usuario }}";
		const mesaId = "{{ mesa.nombre }}";
		const turnoActual = mesa.jugadores.indexOf(jugadorCliente);
		console.log("Volver a la sala de espera: ", jugadorCliente, " mesa: ", mesaId, " indice jugador: ", turnoActual);
		socket.emit('finalizar_partida', { mesa_id: mesaId });
		//window.location.href = '/lobby'; // Redirige a la sala de espera
	});

	document.getElementById('btn-new-game').addEventListener('click', () => {
		const mesa_Id = "{{ mesa.nombre }}";
		console.log("Nueva partida arranca: ", `/mesa_juego/${mesa_Id}`);
		const popup = document.getElementById('popup');
		popup.classList.add('hidden');
		//window.location.href = `/mesa_juego/${mesa_Id}`; // Redirige a la nueva partida
		console.log("Va a hacer emit a PY de reiniciar_partida. data:");
		socket.emit('reiniciar_partida', { table_id: mesa_Id });

		//const btnRepartir = document.getElementById("btn-repartir");
		//btnRepartir.classList.add("oculto");
	});
	
	// Escuchar el evento 'NUEVA PARTIDA' para mostrar los mensajes en el chat
	socket.on('reiniciar_nueva_partida', function(data) {
		console.log("Entra en reiniciar_nueva_partida. data:", data);
		const popup = document.getElementById('popup');
		popup.classList.add('hidden');
		// Actualizar los puntos de la tabla
		document.getElementById('puntos-grande-pareja1').textContent = 0;
		document.getElementById('puntos-chica-pareja1').textContent = 0;
		document.getElementById('puntos-pares-pareja1').textContent = 0;
		document.getElementById('puntos-grande-pareja2').textContent = 0;
		document.getElementById('puntos-chica-pareja2').textContent = 0;
		document.getElementById('puntos-pares-pareja2').textContent = 0;
		// Actualizar los juegos en el marcador
		document.getElementById('puntos-pareja1').textContent = 0;
		document.getElementById('puntos-pareja2').textContent = 0;				
		document.getElementById('juegos-pareja1').textContent = 0;
		document.getElementById('juegos-pareja2').textContent = 0;
		//repartirCartas();
	});
	
	// Escuchar el evento redireccionar_sala_espera enviado desde el servidor
	socket.on('redireccionar_sala_espera', (data) => {
		// Mostrar un mensaje opcional antes de redirigir
		//alert("Volviendo a la sala de espera...");
		console.log("Va a redirigir a la sala de espera");
		// Redirigir al jugador a la sala de espera
		window.location.href = '/lobby'; // Redirige a la sala de espera
	});
	
	
	
	/* function mostrarHablado(jugador, mensaje) {
        let mensajeElemento = document.getElementById(`mensaje-jugador-${jugador}`);
        mensajeElemento.innerText = mensaje;
        mensajeElemento.classList.add("mostrar");
    } */
 
 	async function mostrarHablado(jugador, mensaje) {

        let mensajeElemento = document.getElementById(`mensaje-jugador-${jugador}`);
        mensajeElemento.innerText = mensaje;
        mensajeElemento.classList.add("mostrar");
		await esperado(2000);
	}
	function esperado(ms) {
		return new Promise(resolve => setTimeout(resolve, ms));
	}
  
    function limpiarHablado() {
        document.querySelectorAll(".mensaje-jugador").forEach(el => {
            el.classList.remove("mostrar");
            el.innerText = "";
        });
    }

	// Limpiar bocadillos desde el servidor
	socket.on('limpiaBocadillos', function() {
		limpiarHablado();
	});
	
	// Escuchar errores del servidor
	socket.on('error', function(data) {
		alert(data.message);
	});
	
	</script>
</html>