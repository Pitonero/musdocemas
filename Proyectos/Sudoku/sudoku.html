<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Sudoku</title>
<style>
  body {
    display: flex;
    flex-direction: column;
    align-items: center;
    font-family: Arial, sans-serif;
    margin-top: 20px;
  }
  .sudoku-board {
    display: grid;
    grid-template-columns: repeat(9, 40px);
    grid-template-rows: repeat(9, 40px);
    gap: 2px;
  }
  .sudoku-board div {
    width: 40px;
    height: 40px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 1.5em;
    border: 1px solid #333;
    box-sizing: border-box;
  }
  .sudoku-board div:nth-child(3n) {
    border-right: 3px solid #333;
  }
  .sudoku-board div:nth-child(27n) {
    border-bottom: 3px solid #333;
  }
  .input-cell input {
    width: 100%;
    height: 100%;
    border: none;
    text-align: center;
    font-size: 1.5em;
    outline: none;
  }
  .input-cell input:invalid {
    color: red;
  }
  .buttons {
    margin-top: 20px;
  }
  .buttons button {
    margin: 0 10px;
    padding: 10px 20px;
    font-size: 1em;
  }
</style>
</head>
<body>

<div class="sudoku-board" id="sudoku-board"></div>
<div class="buttons">
  <button onclick="generateSudoku()">Generar Tablero</button>
  <button onclick="solveSudoku()">Resolver</button>
</div>
<div class="message" id="message"></div>

<script>
const boardSize = 9;
const board = Array.from({ length: boardSize }, () => Array(boardSize).fill(0));

function generateSudoku() {
  clearBoard();
  fillBoard();
  removeNumbers();
  renderBoard();
}

function clearBoard() {
  for (let row = 0; row < boardSize; row++) {
    for (let col = 0; col < boardSize; col++) {
      board[row][col] = 0;
    }
  }
}

function fillBoard() {
  for (let row = 0; row < boardSize; row++) {
    for (let col = 0; col < boardSize; col++) {
      if (board[row][col] === 0) {
        const numbers = shuffleArray([1, 2, 3, 4, 5, 6, 7, 8, 9]);
        for (const num of numbers) {
          if (isValid(row, col, num)) {
            board[row][col] = num;
            if (fillBoard()) {
              return true;
            }
            board[row][col] = 0;
          }
        }
        return false;
      }
    }
  }
  return true;
}

function isValid(row, col, num) {
  for (let i = 0; i < boardSize; i++) {
    if (board[row][i] === num || board[i][col] === num) {
      return false;
    }
  }
  const startRow = Math.floor(row / 3) * 3;
  const startCol = Math.floor(col / 3) * 3;
  for (let i = 0; i < 3; i++) {
    for (let j = 0; j < 3; j++) {
      if (board[startRow + i][startCol + j] === num) {
        return false;
      }
    }
  }
  return true;
}

function shuffleArray(array) {
  for (let i = array.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [array[i], array[j]] = [array[j], array[i]];
  }
  return array;
}

function removeNumbers() {
  const numToRemove = 40; // Número de celdas vacías
  let removed = 0;
  while (removed < numToRemove) {
    const row = Math.floor(Math.random() * boardSize);
    const col = Math.floor(Math.random() * boardSize);
    if (board[row][col] !== 0) {
      board[row][col] = 0;
      removed++;
    }
  }
}

function renderBoard() {
  const boardElement = document.getElementById('sudoku-board');
  boardElement.innerHTML = '';
  for (let row = 0; row < boardSize; row++) {
    for (let col = 0; col < boardSize; col++) {
      const cell = document.createElement('div');
      if (board[row][col] === 0) {
        const input = document.createElement('input');
        input.type = 'number';
        input.min = '1';
        input.max = '9';
        input.pattern = '[1-9]';
        input.oninput = function() {
          if (this.value) {
            this.value = this.value.slice(-1);
          }
        };
        cell.appendChild(input);
      } else {
        cell.textContent = board[row][col];
      }
      boardElement.appendChild(cell);
    }
  }
}

function solveSudoku() {
  const userBoard = getUserBoard();
  if (solve(userBoard)) {
    renderSolvedBoard(userBoard);
    document.getElementById('message').textContent = '¡Resuelto!';
  } else {
    document.getElementById('message').textContent = 'No se puede resolver este tablero.';
  }
}

function getUserBoard() {
  const userBoard = Array.from({ length: boardSize }, () => Array(boardSize).fill(0));
  const inputs = document.querySelectorAll('#sudoku-board input');
  inputs.forEach((input, index) => {
    const row = Math.floor(index / boardSize);
    const col = index % boardSize;
    userBoard[row][col] = input.value ? parseInt(input.value) : 0;
  });
  return userBoard;
}

function solve(userBoard) {
  for (let row = 0; row < boardSize; row++) {
    for (let col = 0; col < boardSize; col++) {
      if (userBoard[row][col] === 0) {
        for (let num = 1; num <= boardSize; num++) {
          if (isValid(row, col, num)) {
            userBoard[row][col] = num;
            if (solve(userBoard)) {
              return true;
            }
            userBoard[row][col] = 0;
          }
        }
        return false;
      }
    }
  }
  return true;
}

function renderSolvedBoard(solvedBoard) {
  const boardElement = document.getElementById('sudoku-board');
  const inputs = boardElement.querySelectorAll('input');
  inputs.forEach((input, index) => {
    const row = Math.floor(index / boardSize);
    const col = index % boardSize;
    input.value = solvedBoard[row][col];
  });
}

// Generar un tablero inicial
generateSudoku();
</script>

</body>
</html>